<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>TEA家族 | BarkStarry</title><meta name="author" content="BarkStarry"><meta name="copyright" content="BarkStarry"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="TEA家族一、tea算法1.简介：TEA算法全称微型加密算法（Tiny Encryption Algorithm）是一种简单容易实现的加密算法，通常只需要很少的代码就可以实现。 TEA算法是由剑桥大学计算机实验室的David Wheeler和Roger  Needham于1994年发明的一种分组密码算法。其特点是加密速度快，密钥长度为128比特（16字节），明文和密文块长度均为64比特（8字节）。">
<meta property="og:type" content="article">
<meta property="og:title" content="TEA家族">
<meta property="og:url" content="https://bark66675.github.io/2025/08/05/tea-jia-zu/index.html">
<meta property="og:site_name" content="BarkStarry">
<meta property="og:description" content="TEA家族一、tea算法1.简介：TEA算法全称微型加密算法（Tiny Encryption Algorithm）是一种简单容易实现的加密算法，通常只需要很少的代码就可以实现。 TEA算法是由剑桥大学计算机实验室的David Wheeler和Roger  Needham于1994年发明的一种分组密码算法。其特点是加密速度快，密钥长度为128比特（16字节），明文和密文块长度均为64比特（8字节）。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://bark66675.github.io/img/logo1.png">
<meta property="article:published_time" content="2025-08-04T23:41:36.000Z">
<meta property="article:modified_time" content="2025-08-22T10:12:46.591Z">
<meta property="article:author" content="BarkStarry">
<meta property="article:tag" content="tea">
<meta property="article:tag" content="xtea">
<meta property="article:tag" content="xxtea">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://bark66675.github.io/img/logo1.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "TEA家族",
  "url": "https://bark66675.github.io/2025/08/05/tea-jia-zu/",
  "image": "https://bark66675.github.io/img/logo1.png",
  "datePublished": "2025-08-04T23:41:36.000Z",
  "dateModified": "2025-08-22T10:12:46.591Z",
  "author": [
    {
      "@type": "Person",
      "name": "BarkStarry",
      "url": "https://Bark66675.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon1.ico"><link rel="canonical" href="https://bark66675.github.io/2025/08/05/tea-jia-zu/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'TEA家族',
  isHighlightShrink: true,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      if ($loadingBox.classList.contains('loaded')) return
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()

  if (document.readyState === 'complete') {
    preloader.endLoading()
  } else {
    window.addEventListener('load', preloader.endLoading)
    document.addEventListener('DOMContentLoaded', preloader.endLoading)
    // Add timeout protection: force end after 7 seconds
    setTimeout(preloader.endLoading, 7000)
  }

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/logo1.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">16</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> link</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/favicon1.ico" alt="Logo"><span class="site-name">BarkStarry</span></a><a class="nav-page-title" href="/"><span class="site-name">TEA家族</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> link</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">TEA家族</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-08-04T23:41:36.000Z" title="发表于 2025-08-05 07:41:36">2025-08-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-08-22T10:12:46.591Z" title="更新于 2025-08-22 18:12:46">2025-08-22</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="TEA家族"><a href="#TEA家族" class="headerlink" title="TEA家族"></a>TEA家族</h1><h2 id="一、tea算法"><a href="#一、tea算法" class="headerlink" title="一、tea算法"></a>一、tea算法</h2><h3 id="1-简介："><a href="#1-简介：" class="headerlink" title="1.简介："></a>1.简介：</h3><p>TEA算法全称<font color="LightSteelBlue"><em>微型加密算法</em>（Tiny Encryption Algorithm）</font>是一种简单容易实现的加密算法，通常只需要很少的代码就可以实现。</p>
<p>TEA算法是由剑桥大学计算机实验室的David Wheeler和Roger  Needham于1994年发明的一种分组密码算法。其特点是加密速度快，密钥长度为128比特（16字节），明文和密文块长度均为64比特（8字节）。TEA算法采用Feistel网络结构，通过一系列的线性变换和密钥轮来确保加密的安全性。</p>
<h3 id="2-tea算法核心特征："><a href="#2-tea算法核心特征：" class="headerlink" title="2.tea算法核心特征："></a>2.tea算法核心特征：</h3><ol>
<li><p>.DELTA值和十六个字节（128bit）的密钥</p>
</li>
<li><p>.可以利用ida的插件findcypto识别tea算法</p>
</li>
<li><p>.x <strong>-</strong>=0x61c88647和x <strong>+</strong>=0x9e3779b9，这两个值是等价的，可能会在反汇编中看到</p>
</li>
</ol>
<h3 id="3-tea加密算法原理："><a href="#3-tea加密算法原理：" class="headerlink" title="3.tea加密算法原理："></a>3.tea加密算法原理：</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> v[<span class="number">2</span>] = {*(<span class="type">uint32_t</span> *)&amp;input[i], *(<span class="type">uint32_t</span> *)&amp;input[i<span class="number">+4</span>]};</span><br></pre></td></tr></tbody></table></figure>

<p>这行代码将 input 数组中的字节强制转换为 uint32_t 类型。这里就体现了小端序： 如果输入字符串是 “ABCDEFGH” 在内存中存储为：’A’, ‘B’, ‘C’, ‘D’, ‘E’, ‘F’, ‘G’, ‘H’ 小端序系统会将其解释为： v[0] = 0x44434241 (DCBA) v[1] = 0x48474645 (HGFE)</p>
<p><strong><code>v[0]</code></strong> 的十六进制值 <code>0x44434241</code> 表示字符序列 <code>'D'</code>, <code>'C'</code>, <code>'B'</code>, <code>'A'</code></p>
<ul>
<li><code>0x44434241</code> 在内存中的字节顺序是：<code>0x41, 0x42, 0x43, 0x44</code></li>
<li>对应字符：<code>'A'</code>, <code>'B'</code>, <code>'C'</code>, <code>'D'</code></li>
</ul>
<p>加密后的到整数：0x56371439（<font color="CadetBlue"><strong>必须得到这样的密文才可以还原明文</strong></font>，或者按照小端序存储的顺序输入密文:input[] ={0x39,0x14,0x37,0x56}，在进行*(uint32_t *)&amp;input[i]转化位32位小端序存储，得到的还是uint32_t v[i]={0x56371439},<font color="CadetBlue"><strong>他们两个等价！！</strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<strong>内存中每个32位元素的顺序是不变的，一个元素的值是按小端序存储的</strong></font></p>
<p>加密后的内存存储： 39 14 37 56</p>
<p>解密后的结果：0x44434241<font color="BlueViolet">（得到的是加密还原后的<em><strong>uint32_t v[2]<em><strong>的</strong></em>小端序</strong></em>方式存储的数据，表示的字节序列为’D’，’C’，’B’，’A’）</font></p>
<p>最终结果：ABCD<font color="MediumVioletRed"><strong>（小端序存储在内存中存储的数据A,B,C,D，是明文一个一个字节输入的顺序）</strong></font></p>
<p>还原时把得到的小端序明文转化成可读的字符串：</p>
<h4 id="3-1例题"><a href="#3-1例题" class="headerlink" title="3.1例题"></a>3.1例题</h4><h5 id="加密以及小端序输出的过程："><a href="#加密以及小端序输出的过程：" class="headerlink" title="加密以及小端序输出的过程："></a>加密以及小端序输出的过程：</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">uint32_t</span> k[<span class="number">4</span>] = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>};</span><br><span class="line">    <span class="type">int8_t</span> input[<span class="number">33</span>] = {<span class="number">0</span>};</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%32s"</span>, input);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i+=<span class="number">8</span>) {   <span class="comment">//处理 v 数组中的两个 32 位整数：v[0] 和 v[1]。每个 v[j] 代表一个 32 位的数据块</span></span><br><span class="line">                                    <span class="comment">//64个字节为一组，分为4组.   每组8个字节，每组两个32位整数。</span></span><br><span class="line">        <span class="type">uint32_t</span> v[<span class="number">2</span>] = {*(<span class="type">uint32_t</span> *)&amp;input[i], *(<span class="type">uint32_t</span> *)&amp;input[i+<span class="number">4</span>]};<span class="comment">//每8个字节转为了小端序！！</span></span><br><span class="line">        encrypt(v, k);                        <span class="comment">//加密后得到的同样是小端序，但是解密不需要变换密文，直接使用即可。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) {         <span class="comment">// 这一段主要是把 v 按单字节输出，另外可以了解一下 “大小端序” 在这题是如何体现的</span></span><br><span class="line">                                              <span class="comment">//处理 v 数组中的两个 32 位整数：v[0] 和 v[1]。每个 v[j] 代表一个 32 位的数据块</span></span><br><span class="line">                                              <span class="comment">//这里又将得到的小端序转换为大端序，做了一次变换。</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) {     <span class="comment">//将每个 32 位整数分解为 4 个字节 </span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%#x, "</span>, v[j] &amp; <span class="number">0xff</span>); <span class="comment">//&amp; 0xff - 这是位运算中的"与"操作，0xff 是十六进制数，等于十进制的 255，二进制表示为 11111111</span></span><br><span class="line">                v[j] &gt;&gt;= <span class="number">8</span>;                 <span class="comment">//&gt;&gt;= 8 - 这是右移操作，将 v[j] 的值向右移动 8 位，处理下一个字节，相当于将 v[j] 的值除以 256，2^8=256</span></span><br><span class="line">                                           <span class="comment">//这里的输出先取最低位实际上也是小端序格式输出。因为小端序是低位字节在低地址。</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>当你输⼊正确 flag 时会输出这样的数据：   2<sup>10</sup></p>
<p>0x17, 0x65, 0x54, 0x89, 0xed, 0x65, 0x46, 0x32, 0x3d, 0x58, 0xa9, 0xfd, 0xe2, 0x5e,</p>
<p>0x61, 0x97, 0xe4, 0x60, 0xf1, 0x91, 0x73, 0xe9, 0xe9, 0xa2, 0x59, 0xcb, 0x9a, 0x99,</p>
<p>0xec, 0xb1, 0xe1, 0x7d（*输出密文在小端序系统的内存中的存在方式，每32bit为一组)</p>
<p><em><strong>内存中每个32位元素的顺序是不变的，一个元素的值是按小端序存储的</strong></em></p>
<h5 id="解密过程"><a href="#解密过程" class="headerlink" title="解密过程"></a>解密过程</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">uint32_t</span> raw[<span class="number">8</span>]={<span class="number">0x89546517</span>, <span class="number">0x324665ed</span>, <span class="number">0xfda9583d</span>, <span class="number">0x97615ee2</span>, <span class="number">0x91f160e4</span>, <span class="number">0xa2e9e973</span>, <span class="number">0x999acb59</span>, <span class="number">0x7de1b1ec</span>};</span><br><span class="line">	<span class="comment">//    数值的数学表示（大端序格式）：0x89546517</span></span><br><span class="line">    <span class="comment">//数值的内存布局（小端序存储）：0x17, 0x65, 0x54, 0x89</span></span><br><span class="line">    <span class="comment">//内存中每个32位元素的顺序是不变的，一个元素的值是按小端序存储的</span></span><br><span class="line">    <span class="comment">//所以他可以等价于 uint_8{0x17,0x65,0x54,0x89,0xed,...} ，再进行uint32_t的转换。</span></span><br><span class="line">	<span class="type">uint32_t</span> k[<span class="number">4</span>] = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>};</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++){</span><br><span class="line">		<span class="type">uint32_t</span> v[<span class="number">2</span>]={raw[<span class="number">2</span>*i],raw[<span class="number">2</span>*i+<span class="number">1</span>]};      <span class="comment">//巧妙！！！！！！！！ </span></span><br><span class="line">		tea_decry(v, k);</span><br><span class="line">		<span class="comment">// 将解密后的32位整数转换为字符（考虑小端序）</span></span><br><span class="line">        <span class="type">char</span>* ptr = (<span class="type">char</span>*)v;<span class="comment">//    将v（uint32_t数组）的地址强制转换为char*指针,现在ptr指向    !""内存""!  中第一个字节(原文正确顺序的第一个字节） </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++) {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c"</span>, ptr[j]);</span><br><span class="line">        }</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h4 id="3-2大小端序的体现：代码验证完整流程"><a href="#3-2大小端序的体现：代码验证完整流程" class="headerlink" title="3.2大小端序的体现：代码验证完整流程"></a>3.2大小端序的体现：代码验证完整流程</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">    <span class="comment">// 原始明文 "ABCD"</span></span><br><span class="line">    <span class="type">char</span> text[] = <span class="string">"ABCD"</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"原始明文: %s\n"</span>, text);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"原始字节: "</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) <span class="built_in">printf</span>(<span class="string">"%02X "</span>, text[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 转换为整数（小端序解释）</span></span><br><span class="line">    <span class="type">uint32_t</span> v = *(<span class="type">uint32_t</span>*)text;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"小端序整数: 0x%08X\n"</span>, v);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查看整数在内存中的存储</span></span><br><span class="line">    <span class="type">uint8_t</span>* bytes = (<span class="type">uint8_t</span>*)&amp;v;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"整数内存存储: "</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) <span class="built_in">printf</span>(<span class="string">"%02X "</span>, bytes[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 现在假设我们对整数v进行某种"加密"（简单异或示例）</span></span><br><span class="line">    <span class="type">uint32_t</span> encrypted = v ^ <span class="number">0x12345678</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"加密后整数: 0x%08X\n"</span>, encrypted);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查看加密后整数的内存存储</span></span><br><span class="line">    <span class="type">uint8_t</span>* enc_bytes = (<span class="type">uint8_t</span>*)&amp;encrypted;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"加密后内存存储: "</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) <span class="built_in">printf</span>(<span class="string">"%02X "</span>, enc_bytes[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 解密</span></span><br><span class="line">    <span class="type">uint32_t</span> decrypted = encrypted ^ <span class="number">0x12345678</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"解密后整数: 0x%08X\n"</span>, decrypted);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 转换回字符串</span></span><br><span class="line">    <span class="type">char</span>* result = (<span class="type">char</span>*)&amp;decrypted;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"最终结果: %s\n"</span>, result);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="输出结果："><a href="#输出结果：" class="headerlink" title="输出结果："></a>输出结果：</h5><p>text</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">原始明文: ABCD</span><br><span class="line">原始字节: <span class="number">41</span> <span class="number">42</span> <span class="number">43</span> <span class="number">44</span> </span><br><span class="line">小端序整数: <span class="number">0x44434241</span></span><br><span class="line">整数内存存储: <span class="number">41</span> <span class="number">42</span> <span class="number">43</span> <span class="number">44</span> </span><br><span class="line"></span><br><span class="line">加密后整数: <span class="number">0x56371439</span></span><br><span class="line">加密后内存存储: <span class="number">39</span> <span class="number">14</span> <span class="number">37</span> <span class="number">56</span> </span><br><span class="line">解密后整数: <span class="number">0x44434241</span></span><br><span class="line">最终结果: ABCD</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<h3 id="小端序（Little-Endian）解析："><a href="#小端序（Little-Endian）解析：" class="headerlink" title="小端序（Little-Endian）解析："></a>小端序（Little-Endian）解析：</h3><ol>
<li><p><strong>内存布局</strong>（地址从低到高）：</p>
<p>text</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">| 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' |</span><br><span class="line">  ↑i    i+1  i+2   i+3   i+4   i+5   i+6   i+7</span><br></pre></td></tr></tbody></table></figure>

<p><strong>强制类型转换</strong>：</p>
<ul>
<li><code>&amp;input[i]</code> 指向 <code>'A'</code> 的地址（<code>i=0</code>）</li>
<li><code>*(uint32_t *)&amp;input[i]</code> 会将连续的4字节 <code>'A','B','C','D'</code> 解释为一个 <code>uint32_t</code></li>
</ul>
<p><strong>小端序的存储规则</strong>：</p>
<ul>
<li><p><strong>最低有效字节（LSB）在低地址</strong></p>
</li>
<li><p>实际解释为 <code>uint32_t</code> 时，字节顺序是反的：</p>
<p>text</p>
</li>
<li><pre><code>'A' (0x41) → 最低字节（LSB）
'B' (0x42)
'C' (0x43)
'D' (0x44) → 最高字节（MSB）
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 最终 `v[0] = 0x44434241`（即 `DCBA` 的十六进制拼接）   </span><br><span class="line"></span><br><span class="line">**同理**：</span><br><span class="line"></span><br><span class="line">- `v[1]` 读取 `'E','F','G','H'` → `0x48474645`（`HGFE`）</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line"></span><br><span class="line">int main() {</span><br><span class="line">    char input[9] = "ABCDEFGH";</span><br><span class="line">    </span><br><span class="line">    uint32_t v0 = *(uint32_t *)&amp;input[0];</span><br><span class="line">    uint32_t v1 = *(uint32_t *)&amp;input[4];</span><br><span class="line">    </span><br><span class="line">    printf("v0 = 0x%08x\n", v0);  // 输出: 0x44434241</span><br><span class="line">    printf("v1 = 0x%08x\n", v1);  // 输出: 0x48474645</span><br><span class="line">    </span><br><span class="line">    // 按字节分解查看</span><br><span class="line">    printf("v0 bytes: %c %c %c %c\n", </span><br><span class="line">           (v0 &amp; 0xff), ((v0 &gt;&gt; 8) &amp; 0xff),     //v0 &amp; 0xff是取最低的8位（最低有效字节）</span><br><span class="line">           ((v0 &gt;&gt; 16) &amp; 0xff), ((v0 &gt;&gt; 24) &amp; 0xff));</span><br><span class="line">    // 输出: A B C D</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</code></pre>
</li>
</ul>
</blockquote>
<p>加密过程中，64位的明文分成两个32位（4字节）的部分即v0，v1。</p>
<blockquote>
<p>例如，一个 64 位整数 <code>0x1122334455667788</code> 会被拆分为：</p>
<ul>
<li><code>v0 = 0x11223344</code>（高 32 位）</li>
<li><code>v1 = 0x55667788</code>（低 32 位）</li>
</ul>
</blockquote>
<p>明文按8字节为一组再进行分为两个4字节的元素。</p>
<p><em><em>uint32_t</em> v</em>*（v在这里是数组，定义了这个数组v每个元素都是32位，往后可以把每个元素如v[0],v[1]赋值给v0，v1。最后加密完再把每个v0，v1重新赋值给数组v）。</p>
<p><em><em>uint32_t</em> k</em>* 同理。</p>
<ul>
<li><font color="brown-red" face="华文新魏" size="4"><strong>严格遵循无符号32位运算</strong></font></li>
</ul>
<h4 id="3-3加密过程："><a href="#3-3加密过程：" class="headerlink" title="3.3加密过程："></a>3.3加密过程：</h4><h5 id="配合dev里面的teaNSSCTF脚本食用，题目是revers，NSSCTF的TEA文件"><a href="#配合dev里面的teaNSSCTF脚本食用，题目是revers，NSSCTF的TEA文件" class="headerlink" title="//配合dev里面的teaNSSCTF脚本食用，题目是revers，NSSCTF的TEA文件"></a>//配合dev里面的teaNSSCTF脚本食用，题目是revers，NSSCTF的TEA文件</h5><ol>
<li><p>初始化：</p>
<p><em><em>uint32_t</em> k</em>*：初始化一个每个元素都是32位的数组k，选择一个128bit的密钥，分为四个32位无符号整数k[1]，k[2]，k[3]，k[4]赋值到数组k里面。</p>
<p><em><em>uint32_t</em> v</em>*：初始化一个每个元素都是32位的数组v，两个32位组成一组（v[0]，v[1]）一起参与接下来的32轮加密。   //：v[0]，v[1]是明文的左右部分。</p>
</li>
<li><p>加密过程：</p>
<ul>
<li><p>初始化变量：</p>
<p><code>uint32_t v0=v[0]，v1=v[1]</code></p>
<p><code>uint32_t sum=0</code></p>
<p><code>uint32_t delta = 0x9e3779b9</code></p>
</li>
<li><p>进行32轮加密：</p>
<ul>
<li><p>每轮加密包括以下内容：</p>
<p><code>sum += delta</code></p>
<p><code>v0 += ((v1&lt;&lt;4) + k[0]) ^ (v1 + sum) ^ ((v1 &gt;&gt; 5) + k[1]);</code></p>
<p><code>v1 += ((v0&lt;&lt;4) + k[2]) ^ (v0 + sum) ^ ((v0  &gt;&gt; 5) + k[3])</code></p>
</li>
</ul>
</li>
<li><p>更新v[0]，v[1]：</p>
<p>v[0]=v0 ; v[1]=v1</p>
<p><font color="brown-red" face="华文新魏" size="4"><strong>加密后的结果实际上就是小端序数据！！！</strong>。数值的内存布局（小端序存储）：0x17, 0x65, 0x54, 0x89。&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 输出的密文：0x89546517</font>  </p>
<p><font color="brown-red" face="华文新魏" size="4"><strong>内存中每个32位元素的顺序是不变的，一个元素的值是按小端序存储的</strong></font></p>
</li>
</ul>
</li>
<li><p>加密解密完整代码：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//加密函数：</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tea_enc</span><span class="params">(<span class="type">uint32_t</span>* v, <span class="type">uint32_t</span>* k)</span> </span>{</span><br><span class="line">    <span class="type">uint32_t</span> v0 = v[<span class="number">0</span>], v1 = v[<span class="number">1</span>];  <span class="comment">// v0、v1分别是明文的左、右半部分</span></span><br><span class="line">    <span class="type">uint32_t</span> sum = <span class="number">0</span>;               <span class="comment">// sum用作加密过程中的一个累加变量</span></span><br><span class="line">    <span class="type">uint32_t</span> delta = <span class="number">0x9e3779b9</span>;     <span class="comment">//作为sum每次累加的变化值，题目中往往会修改此值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) {  <span class="comment">// tea加密进行32轮</span></span><br><span class="line">    <span class="comment">//以下3行是核心加密过程，题目中往往会对部分细节做出修改（但由于异或的对称性质，根本不需要记，写解密函数时照抄就行了）</span></span><br><span class="line">        sum += delta;</span><br><span class="line">        v0 += ((v1 &lt;&lt; <span class="number">4</span>) + k[<span class="number">0</span>]) ^ (v1 + sum) ^ ((v1 &gt;&gt; <span class="number">5</span>) + k[<span class="number">1</span>]);</span><br><span class="line">        v1 += ((v0 &lt;&lt; <span class="number">4</span>) + k[<span class="number">2</span>]) ^ (v0 + sum) ^ ((v0 &gt;&gt; <span class="number">5</span>) + k[<span class="number">3</span>]);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// v0和v1只是加密的临时变量，因此加密后的内容要还给v数组</span></span><br><span class="line">    v[<span class="number">0</span>] = v0;</span><br><span class="line">    v[<span class="number">1</span>] = v1;</span><br><span class="line">    <span class="comment">//加密后的结果实际上就是小端序数据！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//解密函数：</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tea_dec</span><span class="params">(<span class="type">uint32_t</span>* v, <span class="type">uint32_t</span>* k)</span> </span>{</span><br><span class="line">    <span class="type">uint32_t</span> v0 = v[<span class="number">0</span>], v1 = v[<span class="number">1</span>];  <span class="comment">// v0、v1分别是密文的左、右半部分</span></span><br><span class="line">    <span class="type">uint32_t</span> delta = <span class="number">0x9e3779b9</span>;     <span class="comment">//作为sum每次累加的变化值，题目中往往会修改此值</span></span><br><span class="line">    <span class="type">uint32_t</span> sum = <span class="number">32</span> * delta;      <span class="comment">//此处需要分析32轮加密结束后sum的值与delta的变化, 以此处加密为例子，32轮每次sum+=delta，因此最后sum=32*delta</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) {  <span class="comment">// tea加密进行32轮</span></span><br><span class="line">        <span class="comment">//根据加密时的顺序颠倒下面3行的顺序，将加法改为减法（异或部分都是整体，不用管），就是逆向解密过程</span></span><br><span class="line">        v1 -= ((v0 &lt;&lt; <span class="number">4</span>) + k[<span class="number">2</span>]) ^ (v0 + sum) ^ ((v0 &gt;&gt; <span class="number">5</span>) + k[<span class="number">3</span>]);</span><br><span class="line">        v0 -= ((v1 &lt;&lt; <span class="number">4</span>) + k[<span class="number">0</span>]) ^ (v1 + sum) ^ ((v1 &gt;&gt; <span class="number">5</span>) + k[<span class="number">1</span>]);</span><br><span class="line">        sum -= delta;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 因此解密后的内容要还给v数组</span></span><br><span class="line">    v[<span class="number">0</span>] = v0;</span><br><span class="line">    v[<span class="number">1</span>] = v1;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">uint32_t</span> v[<span class="number">2</span>]={<span class="number">1</span>,<span class="number">2</span>},k[<span class="number">4</span>]={<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>};</span><br><span class="line">    <span class="comment">// v为要加密的数据是两个32位无符号整数</span></span><br><span class="line">    <span class="comment">// k为加密解密密钥，为4个32位无符号整数，即密钥长度为128位</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"加密前原始数据：%u %u\n"</span>,v[<span class="number">0</span>],v[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">encrypt</span>(v, k);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"加密后的数据：%u %u\n"</span>,v[<span class="number">0</span>],v[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">decrypt</span>(v, k);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"解密后的数据：%u %u\n"</span>,v[<span class="number">0</span>],v[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h2 id="二、xtea算法"><a href="#二、xtea算法" class="headerlink" title="二、xtea算法"></a>二、xtea算法</h2><h3 id="1-简介：-1"><a href="#1-简介：-1" class="headerlink" title="1.简介："></a>1.简介：</h3><p>使用与TEA相同的简单运算，但四个子密钥采取不正规的方式进行混合以阻止密钥表攻击。  </p>
<h3 id="2-加解密过程："><a href="#2-加解密过程：" class="headerlink" title="2.加解密过程："></a>2.加解密过程：</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* take 64 bits of data in v[0] and v[1] and 128 bits of key[0] - key[3] */</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">encipher</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> num_rounds, <span class="type">uint32_t</span> v[<span class="number">2</span>], <span class="type">uint32_t</span> <span class="type">const</span> key[<span class="number">4</span>])</span> </span>{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">    <span class="type">uint32_t</span> v0=v[<span class="number">0</span>], v1=v[<span class="number">1</span>], sum=<span class="number">0</span>, delta=<span class="number">0x9E3779B9</span>;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; num_rounds; i++) {</span><br><span class="line">        v0 += (((v1 &lt;&lt; <span class="number">4</span>) ^ (v1 &gt;&gt; <span class="number">5</span>)) + v1) ^ (sum + key[sum &amp; <span class="number">3</span>]);</span><br><span class="line">        <span class="comment">//sum &amp; 3：对sum进行按位与操作，相当于 sum % 4，因为3的二进制是0011，所以这个操作取sum的最低2位。</span></span><br><span class="line">        sum += delta;</span><br><span class="line">        v1 += (((v0 &lt;&lt; <span class="number">4</span>) ^ (v0 &gt;&gt; <span class="number">5</span>)) + v0) ^ (sum + key[(sum&gt;&gt;<span class="number">11</span>) &amp; <span class="number">3</span>]);</span><br><span class="line">    }</span><br><span class="line">    v[<span class="number">0</span>]=v0; v[<span class="number">1</span>]=v1;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">decipher</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> num_rounds, <span class="type">uint32_t</span> v[<span class="number">2</span>], <span class="type">uint32_t</span> <span class="type">const</span> key[<span class="number">4</span>])</span> </span>{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">    <span class="type">uint32_t</span> v0=v[<span class="number">0</span>], v1=v[<span class="number">1</span>], delta=<span class="number">0x9E3779B9</span>, sum=delta*num_rounds;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; num_rounds; i++) {</span><br><span class="line">        v1 -= (((v0 &lt;&lt; <span class="number">4</span>) ^ (v0 &gt;&gt; <span class="number">5</span>)) + v0) ^ (sum + key[(sum&gt;&gt;<span class="number">11</span>) &amp; <span class="number">3</span>]);</span><br><span class="line">        sum -= delta;</span><br><span class="line">        v0 -= (((v1 &lt;&lt; <span class="number">4</span>) ^ (v1 &gt;&gt; <span class="number">5</span>)) + v1) ^ (sum + key[sum &amp; <span class="number">3</span>]);</span><br><span class="line">    }</span><br><span class="line">    v[<span class="number">0</span>]=v0; v[<span class="number">1</span>]=v1;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">uint32_t</span> v[<span class="number">2</span>]={<span class="number">1</span>,<span class="number">2</span>};</span><br><span class="line">    <span class="type">uint32_t</span> <span class="type">const</span> k[<span class="number">4</span>]={<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>};</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> r=<span class="number">32</span>;<span class="comment">//num_rounds建议取值为32</span></span><br><span class="line">    <span class="comment">// v为要加密的数据是两个32位无符号整数</span></span><br><span class="line">    <span class="comment">// k为加密解密密钥，为4个32位无符号整数，即密钥长度为128位</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"加密前原始数据：%u %u\n"</span>,v[<span class="number">0</span>],v[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">encipher</span>(r, v, k);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"加密后的数据：%u %u\n"</span>,v[<span class="number">0</span>],v[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">decipher</span>(r, v, k);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"解密后的数据：%u %u\n"</span>,v[<span class="number">0</span>],v[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="三、XXTEA算法"><a href="#三、XXTEA算法" class="headerlink" title="三、XXTEA算法"></a>三、XXTEA算法</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DELTA 0x9e3779b9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MX (((z&gt;&gt;5^y<span class="string">&lt;&lt;2) + (y&gt;</span>&gt;3^z&lt;&lt;4)) ^ ((sum^y) + (key[(p&amp;3)^e] ^ z)))</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">btea</span><span class="params">(<span class="type">uint32_t</span> *v, <span class="type">int</span> n, <span class="type">uint32_t</span> <span class="type">const</span> key[<span class="number">4</span>])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">uint32_t</span> y, z, sum;</span><br><span class="line">    <span class="type">unsigned</span> p, rounds, e;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>)            <span class="comment">/* Coding Part */</span></span><br><span class="line">    {</span><br><span class="line">        rounds = <span class="number">6</span> + <span class="number">52</span>/n;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        z = v[n<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        {</span><br><span class="line">            sum += DELTA;</span><br><span class="line">            e = (sum &gt;&gt; <span class="number">2</span>) &amp; <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">for</span> (p=<span class="number">0</span>; p&lt;n<span class="number">-1</span>; p++)</span><br><span class="line">            {</span><br><span class="line">                y = v[p<span class="number">+1</span>];</span><br><span class="line">                z = v[p] += MX;</span><br><span class="line">            }</span><br><span class="line">            y = v[<span class="number">0</span>];</span><br><span class="line">            z = v[n<span class="number">-1</span>] += MX;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span> (--rounds);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n &lt; <span class="number">-1</span>)      <span class="comment">/* Decoding Part */</span></span><br><span class="line">    {</span><br><span class="line">        n = -n;</span><br><span class="line">        rounds = <span class="number">6</span> + <span class="number">52</span>/n;</span><br><span class="line">        sum = rounds*DELTA;</span><br><span class="line">        y = v[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        {</span><br><span class="line">            e = (sum &gt;&gt; <span class="number">2</span>) &amp; <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">for</span> (p=n<span class="number">-1</span>; p&gt;<span class="number">0</span>; p--)</span><br><span class="line">            {</span><br><span class="line">                z = v[p<span class="number">-1</span>];</span><br><span class="line">                y = v[p] -= MX;</span><br><span class="line">            }</span><br><span class="line">            z = v[n<span class="number">-1</span>];</span><br><span class="line">            y = v[<span class="number">0</span>] -= MX;</span><br><span class="line">            sum -= DELTA;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span> (--rounds);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">uint32_t</span> v[<span class="number">2</span>]= {<span class="number">1</span>,<span class="number">2</span>};</span><br><span class="line">    <span class="type">uint32_t</span> <span class="type">const</span> k[<span class="number">4</span>]= {<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>};</span><br><span class="line">    <span class="type">int</span> n= <span class="number">2</span>; <span class="comment">//n的绝对值表示v的长度，取正表示加密，取负表示解密</span></span><br><span class="line">    <span class="comment">// v为要加密的数据是两个32位无符号整数</span></span><br><span class="line">    <span class="comment">// k为加密解密密钥，为4个32位无符号整数，即密钥长度为128位</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"加密前原始数据：%u %u\n"</span>,v[<span class="number">0</span>],v[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">btea</span>(v, n, k);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"加密后的数据：%u %u\n"</span>,v[<span class="number">0</span>],v[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">btea</span>(v, -n, k);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"解密后的数据：%u %u\n"</span>,v[<span class="number">0</span>],v[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>





<hr>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zpchcbd/p/15974293.html" title="很清晰的教程">TEA/XTEA/XXTEA系列算法</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/liKeQing1027520/article/details/141287289">tea 加密解密算法（面向ctf-reverse使用，光速学会tea逆向套路</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_35671843/article/details/148127998">TEA加密算法在C++中的实现及应用</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/sk2rw/p/14797633.html">逆向算法之TEA算法</a></p>
<p><a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-266933.htm">[看雪原创]TEA、XTEA、XXTEA加解密过程及案例</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_73644864/article/details/130675396">XTEA加密算法实现过程</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://Bark66675.github.io">BarkStarry</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://bark66675.github.io/2025/08/05/tea-jia-zu/">https://bark66675.github.io/2025/08/05/tea-jia-zu/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://Bark66675.github.io" target="_blank">BarkStarry</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/tea/">tea</a><a class="post-meta__tags" href="/tags/xtea/">xtea</a><a class="post-meta__tags" href="/tags/xxtea/">xxtea</a></div><div class="post-share"><div class="social-share" data-image="/img/logo1.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/2025/07/27/rc4/" title="rc4"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">rc4</div></div><div class="info-2"><div class="info-item-1">rc4加密过程  密钥调度算法（KSA）（Key Scheduling Algorithm） 初始化一个长度为256的数组S，值为S[i]=i,其中i是索引.  根据密钥（char类型）和S[i]生成j，S[j],并进行置换: j=0 j=j+S[i]+key[i%len(key)]%256 交换S[i]和S[j]   伪随机数生成算法（PRGA） 初始化两个索引变量：i，j=0 i = (i+1)%256 j = (j+s[i])%256 交换S[i]和S[j] t = ( S[i]+S[j] )%256 KEY = S[t]   </div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/logo1.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">BarkStarry</div><div class="author-info-description">奔赴山海，保持热爱</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">16</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">刺骨的寒冬，孕育出新生的希望。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#TEA%E5%AE%B6%E6%97%8F"><span class="toc-number">1.</span> <span class="toc-text">TEA家族</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81tea%E7%AE%97%E6%B3%95"><span class="toc-number">1.1.</span> <span class="toc-text">一、tea算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%AE%80%E4%BB%8B%EF%BC%9A"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.简介：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-tea%E7%AE%97%E6%B3%95%E6%A0%B8%E5%BF%83%E7%89%B9%E5%BE%81%EF%BC%9A"><span class="toc-number">1.1.2.</span> <span class="toc-text">2.tea算法核心特征：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-tea%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="toc-number">1.1.3.</span> <span class="toc-text">3.tea加密算法原理：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1%E4%BE%8B%E9%A2%98"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">3.1例题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A0%E5%AF%86%E4%BB%A5%E5%8F%8A%E5%B0%8F%E7%AB%AF%E5%BA%8F%E8%BE%93%E5%87%BA%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="toc-number">1.1.3.1.1.</span> <span class="toc-text">加密以及小端序输出的过程：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E5%AF%86%E8%BF%87%E7%A8%8B"><span class="toc-number">1.1.3.1.2.</span> <span class="toc-text">解密过程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2%E5%A4%A7%E5%B0%8F%E7%AB%AF%E5%BA%8F%E7%9A%84%E4%BD%93%E7%8E%B0%EF%BC%9A%E4%BB%A3%E7%A0%81%E9%AA%8C%E8%AF%81%E5%AE%8C%E6%95%B4%E6%B5%81%E7%A8%8B"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">3.2大小端序的体现：代码验证完整流程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C%EF%BC%9A"><span class="toc-number">1.1.3.2.1.</span> <span class="toc-text">输出结果：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%AB%AF%E5%BA%8F%EF%BC%88Little-Endian%EF%BC%89%E8%A7%A3%E6%9E%90%EF%BC%9A"><span class="toc-number">1.1.4.</span> <span class="toc-text">小端序（Little-Endian）解析：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3%E5%8A%A0%E5%AF%86%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">3.3加密过程：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%85%8D%E5%90%88dev%E9%87%8C%E9%9D%A2%E7%9A%84teaNSSCTF%E8%84%9A%E6%9C%AC%E9%A3%9F%E7%94%A8%EF%BC%8C%E9%A2%98%E7%9B%AE%E6%98%AFrevers%EF%BC%8CNSSCTF%E7%9A%84TEA%E6%96%87%E4%BB%B6"><span class="toc-number">1.1.4.1.1.</span> <span class="toc-text">&#x2F;&#x2F;配合dev里面的teaNSSCTF脚本食用，题目是revers，NSSCTF的TEA文件</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81xtea%E7%AE%97%E6%B3%95"><span class="toc-number">1.2.</span> <span class="toc-text">二、xtea算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%AE%80%E4%BB%8B%EF%BC%9A-1"><span class="toc-number">1.2.1.</span> <span class="toc-text">1.简介：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8A%A0%E8%A7%A3%E5%AF%86%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.加解密过程：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81XXTEA%E7%AE%97%E6%B3%95"><span class="toc-number">1.3.</span> <span class="toc-text">三、XXTEA算法</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/05/tea-jia-zu/" title="TEA家族">TEA家族</a><time datetime="2025-08-04T23:41:36.000Z" title="发表于 2025-08-05 07:41:36">2025-08-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/27/rc4/" title="rc4">rc4</a><time datetime="2025-07-27T05:58:08.000Z" title="发表于 2025-07-27 13:58:08">2025-07-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/27/z3-yue-shu-qiu-jie-qi/" title="z3约束求解器">z3约束求解器</a><time datetime="2025-07-26T19:37:35.000Z" title="发表于 2025-07-27 03:37:35">2025-07-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/03/chang-jian-han-shu-yong-fa/" title="常见函数用法">常见函数用法</a><time datetime="2025-07-03T12:15:18.000Z" title="发表于 2025-07-03 20:15:18">2025-07-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/03/ji-cun-qi-xun-zhi-fang-shi/" title="寄存器寻址方式">寄存器寻址方式</a><time datetime="2025-07-03T03:39:31.000Z" title="发表于 2025-07-03 11:39:31">2025-07-03</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By BarkStarry</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.0</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>