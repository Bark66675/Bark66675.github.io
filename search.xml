<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>“gcc编译”</title>
      <link href="/2025/03/08/gcc-bian-yi/"/>
      <url>/2025/03/08/gcc-bian-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="C-编译全过程"><a href="#C-编译全过程" class="headerlink" title="C++编译全过程"></a>C++编译全过程</h1><hr><p>gcc flag.c -o flag(用gcc编译成可执行文件)  </p><h2 id="一、四个步骤："><a href="#一、四个步骤：" class="headerlink" title="一、四个步骤："></a>一、四个步骤：</h2><ol><li><p>预处理（Processing）  </p><p>  gcc -E flag.cpp -o flag.ii    <code>-E     Preprocess only; do not compile, assemble or link.</code></p></li><li><p>编译（Compilation）   </p><p>  gcc -S flag.ii -o flag.s       <code>-S      Compile only; do not assemble or link.</code></p></li><li><p>汇编（Assemble）     </p><p>  gcc -c flag.s  -o flag.o      <code>-c      Compile and assemble, but do not link.</code>  </p><p>  nasm -f elf64 -o flag.o flag.asm    # 使用 nasm 将 .asm 文件编译成 .o 文件  </p><p>  (有的asm文件nasm汇编后需要这样操作，因为他是NASM语法编写的代码，gcc无法直接处理)  </p></li><li><p>链接（linking）   </p><p>gcc -o flag flag.o           <code>-o &lt;file&gt;     Place the output into &lt;file&gt;.</code>  </p><p>ld -s -o flag flag.o     //生成可执行文件flag，-s表示在可执行文件中去掉符号表和调试信息，使得可执行文件更小。</p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250308143451.png"></p><p><img src="/image/R-C.png"></p><p><img src="/image/6ef2706a58025f5f63e7d2468db35530.png"></p></li></ol><h2 id="二、各个步骤详解："><a href="#二、各个步骤详解：" class="headerlink" title="二、各个步骤详解："></a>二、各个步骤详解：</h2><p>1. </p>]]></content>
      
      
      
        <tags>
            
            <tag> C++编译过程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编助记符</title>
      <link href="/2025/03/08/hui-bian-zhu-ji-fu/"/>
      <url>/2025/03/08/hui-bian-zhu-ji-fu/</url>
      
        <content type="html"><![CDATA[<p>offset取偏移地址，不去地址的值。  </p><p>[esi]指向对应地址的值。  </p>]]></content>
      
      
      
        <tags>
            
            <tag> 汇编语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Base64编码解析</title>
      <link href="/2025/03/06/bit/"/>
      <url>/2025/03/06/bit/</url>
      
        <content type="html"><![CDATA[<h1 id="Base64编码解析"><a href="#Base64编码解析" class="headerlink" title="Base64编码解析"></a>Base64编码解析</h1><hr><h2 id="计算机单位解析"><a href="#计算机单位解析" class="headerlink" title="计算机单位解析"></a>计算机单位解析</h2><h3 id="一、位，字节，的定义"><a href="#一、位，字节，的定义" class="headerlink" title="一、位，字节，的定义"></a>一、位，字节，的定义</h3><p>1.<a href="https://www.baidu.com/s?wd=bit&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao">bit</a>（Binary Digits）就是<a href="https://baike.baidu.com/item/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E5%AD%97/5920908?fromModule=lemma_inlink">二进制数字</a>中的位，是信息量的度量单位，为信息量的最小单位，也叫<a href="https://www.baidu.com/s?wd=%E6%AF%94%E7%89%B9%E4%BD%8D&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao">比特位</a>，<em><strong>存放一位二进制数，即0或1</strong></em>，是计算机表示数据最小的单位。  （b）</p><p>2.<a href="https://www.baidu.com/s?wd=byte&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao">byte</a>就是字节，字节(Byte)是计量单位，是计算机的基本存储单位，表示数据量多少，是计算机信息技术用于计量存储容量的一种计量单位.通常情况下一字节等于8位，一个字节由8个相邻的二进制位组成，每个位由0或1组成。字节是计算机技术中最小的可操作存储单位。  （B）  </p><h3 id="二、换算"><a href="#二、换算" class="headerlink" title="二、换算"></a>二、换算</h3><ol><li>​    1byte=8bit</li><li>​    1KB=1024B</li><li>​    1MB=1024KB</li><li>​    1G=1024MB</li><li>​    1tb=1024gb  </li><li>​    1pb=1024tb</li></ol><h3 id="三、字节与字符"><a href="#三、字节与字符" class="headerlink" title="三、字节与字符"></a>三、字节与字符</h3><ul><li><p>字符的定义：</p><ul><li><p>字符(Character)计算机中使用的字母、数字、字和符号，比如’A’、’B’、’$’、’&amp;’等。</p><p>一般在英文状态下一个字母或字符占用一个字节，一个汉字用两个字节表示。</p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250306205915.png"></p></li></ul></li></ul><ol><li>ASCII 码中，一个英文字母（不分大小写）为一个字节，一个中文汉字为两个字节。</li><li>UTF-8 编码中，一个英文字为一个字节，一个中文为三个字节。  </li><li>Unicode 编码中，一个英文为一个字节，一个中文为两个字节。  </li><li>符号：英文标点为一个字节，中文标点为两个字节。例如：英文句号 . 占1个字节的大小，中文句号  。占2个字节的大小。  </li><li>UTF-16 编码中，一个英文字母字符或一个汉字字符存储都需要 2 个字节（Unicode 扩展区的一些汉字存储需要 4 个字节）。  </li><li>UTF-32 编码中，世界上任何字符的存储都需要 4 个字节。</li></ol><h2 id="base64原理解析"><a href="#base64原理解析" class="headerlink" title="base64原理解析"></a>base64原理解析</h2><h3 id="1-base64是什么："><a href="#1-base64是什么：" class="headerlink" title="1.base64是什么："></a>1.base64是什么：</h3><blockquote><p>Base64 是一种基于 64 个可打印字符来表示<a href="https://zhida.zhihu.com/search?content_id=112952835&amp;content_type=Article&amp;match_order=1&amp;q=%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E6%8D%AE&amp;zhida_source=entity">二进制数据</a>的表示方法。由于 2^6=64，所以每 6 个比特为一个单元，对应某个可打印字符。3 个字节有 24 个比特，对应于 4 个 Base64 单元，即 3 个字节可由 4 个可打印字符来表示。<br>——维基百科</p></blockquote><p>它不是一种加解密技术，是一种简单的编解码技术。  </p><p>Base64 常用于表示、传输、存储二进制数据，也可以用于将一些含有特殊字符的文本内容编码，以便传输。</p><p>比如：</p><ol><li>在电子邮件的传输中，Base64 可以用来将 binary 的字节序列，比如附件，编码成 ASCII 字节序列；</li><li>将一些体积不大的图片 Base64 编码后，直接内嵌到网页源码里；</li><li>将要传递给 HTTP 请求的参数做简单的转换，降低肉眼可读性；<br><em>注：用于 URL 的 Base64 非标准 Base64，是一种变种。</em></li><li>网友们在论坛等公开场合习惯将邮箱地址 Base64 后再发出来，防止被爬虫抓取后发送垃圾邮件。</li></ol><h3 id="2-base64编码原理："><a href="#2-base64编码原理：" class="headerlink" title="2.base64编码原理："></a>2.base64编码原理：</h3><p>标准 Base64 里的 64 个可打印字符是 <code>A-Za-z0-9+/</code>，分别依次对应索引值 0-63。  </p><p>其中：  </p><p>​         <code>A-Z</code>、<code>a-z</code>、<code>0-9</code> 共 62 个字符</p><p>​         <code>+</code> 和 <code>/</code> 用作填充字符</p><p>​         <code>=</code> 用作填充符，使数据长度对齐到 4 字节</p><ul><li><p><strong>具体步骤</strong>：  </p><ol><li><p>将输入数据转换为二进制</p></li><li><p>将待转换的字符串每三个字节分为一组，每个字节占8bit，那么共有24个二进制位。 </p></li><li><p>将上面的24个二进制位每6个一组，共分为4组，每组对应 Base64 字符集中的一个字符，根据 Base64 字符集查找对应字符  </p></li><li><p>如果数据长度不是 3 的倍数，则先进行补0处理，再使用 <code>=</code> 填充</p><ul><li>如果最后剩下 1 个字节，那么将补 4 个 0 位，编码成 2 个 Base64 字符，然后补两个 <code>=</code></li><li>如果最后剩下 2 个字节，那么将补 2 个 0 位，编码成 3 个 Base64 字符，然后补一个 <code>=</code></li></ul><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250306212941.png">   </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250306213033.png"></p></li></ol><hr><p>参考文章：</p><p><a href="https://zhuanlan.zhihu.com/p/111700349">https://zhuanlan.zhihu.com/p/111700349</a></p><p><a href="https://www.cnblogs.com/happy-coding/p/18747324">https://www.cnblogs.com/happy-coding/p/18747324</a></p><p><a href="https://www.runoob.com/w3cnote/byte-character.html">https://www.runoob.com/w3cnote/byte-character.html</a></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机单位 </tag>
            
            <tag> 字节与字符 </tag>
            
            <tag> base64编码原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>f5报错的几种类型</title>
      <link href="/2025/03/05/f5-chu-cuo-lei-xing/"/>
      <url>/2025/03/05/f5-chu-cuo-lei-xing/</url>
      
        <content type="html"><![CDATA[<h1 id="f5生成伪代码出错的几种类型"><a href="#f5生成伪代码出错的几种类型" class="headerlink" title="f5生成伪代码出错的几种类型"></a>f5生成伪代码出错的几种类型</h1><hr><h2 id="常见F5出错信息"><a href="#常见F5出错信息" class="headerlink" title="常见F5出错信息"></a>常见F5出错信息</h2><p>1.<code>posutuve sp value has been found </code> </p><ul><li><p><strong>成因</strong>：IDA会自动分析SP寄存器的变化量，由于缺少调用约定、参数个数等信息，导致分析出错。 一般是程序代码有一些干扰代码，让IDA的反汇编分析出现错误。比如用push + n条指令 + retn来实际跳转，而IDA会以为retn是函数要结束，结果它分析后发现调用栈不平衡，因此就提示sp analysis failed。  </p></li><li><p><strong>解决方案</strong>：Option-&gt;General设置显示Stack Pointer，检查对应地址附近的调用约定以及栈指针变化。直接使用alt+k修改sp指针，将其修改为应有的值即可（可以改为指向上一行的sp或者修改为0）。（有风险）    </p></li><li><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250305210451.png"></p></li></ul><p>2.<code> cannot convert to microcode</code></p><ul><li><p><strong>成因</strong>：部分指令无法被反编译，有未设置成指令的数据字节。  </p></li><li><p><strong>解决方案</strong>：</p><ul><li>最常见起因是函数中有未设置成指令的数据字节，按c将其设置为指令即可。  </li><li>其次常见的是x86中的rep前缀，比如repxx  jmp等。可以将该指令的第一个字节(repxx前缀的对应位置)patch为0x90 (NOP)。</li><li><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250305200132.png"></li></ul></li><li><p>也可以先点击函数点u将其取消定义。  </p></li><li><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250305212604.png">  </p></li><li><p>然后选中下面所有数据内容，按C转换为代码。  </p></li><li><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250305212730.png">    </p></li><li><p>点击force  </p></li><li><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250305213156.png">  </p></li><li><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250305213246.png"></p></li><li><p>点击yes</p></li><li><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250305213235.png">  </p></li><li><p>之后再点击_Z7进行P定义为函数，再用F5反编译。这里可以得到encrypt函数。</p></li><li><p>下面如果还有红色的不要忘记也P一下，创建函数。</p></li></ul><p>3.<code>call analysis failed</code></p><ul><li><p>成因：F5在分析调用时，未能成功解析<em>参数位置/参数个苏</em></p></li><li><p>解决方案：</p><ul><li><p>对于间接调用（类似call eax等），可使用之前讲过的<em>设置调用地址</em>的方法解决。  </p></li><li><p>对于直接调用，查看调用目标的type是否正确设置。<em>可变参数</em>是引发这种错误的主要原因之一。  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250305202146.png"></p></li></ul></li></ul><p>4.<code>stack frame is too big</code></p><ul><li>成因：在分析栈帧时，IDA出现异常，导致分析出错</li><li>解决方案：<ul><li>找到明显不合常理的stack variable offset，双击进入栈帧界面，按u键删除对应的stack variable</li><li>如果是去壳导致的原因，先用OD等软件脱壳</li><li>可能由花指令导致，请手动或自动检查并去除花指令</li></ul></li><li>非常罕见</li></ul><p>5.<code>too big function</code> </p><ul><li><p>成因：当前函数大小大于允许的最大值，函数大小最大值有配置文件中的<code>MAX_FUNCSIZE </code>变量控制。  </p><p>MAX_FUNCSIZE 的定义:</p><blockquote><p>反编译函数大小最大值，使用KB单位计算。只有可读的基本块被统计在内。默认值是64，即64KB。出现这个报错，说明反编译函数的大小已经超过了64。</p></blockquote></li><li><p>解决方案：</p><p>​     1.修改配置文件：<code>【IDA 安装目录】\cfg\hexrays.cfg</code></p><p>​      源文件为：</p><ul><li><blockquote><p>MAX_FUNCSIZE            = 64        // Functions over 64K are not decompiled</p></blockquote><p>修改为：</p></li><li><blockquote><p>MAX_FUNCSIZE            = 1024        // Functions over 64K are not decompiled</p></blockquote><p>2.重新启动IDA，使配置生效。  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250305204340.png"></p></li></ul></li></ul><p>如果函数太大，逻辑太负载，及时调大<strong>MAX_FUNCSIZE</strong>也会出现新的错误，比如<strong>too complex function</strong>，这种情况就无能为力了。官方也解决不了。</p><p>如果调大以后，出现卡死问题，建议把值调小一些。</p><p>6.<code>local variable allocation failed</code>  </p><ul><li>成因： 分析函数时，有部分变量对应的区域发生重叠，多见于ARM平台出现Point、Rect等8字节、16字节、32字节结构</li><li>解决方案<ul><li>修改对应参数为多个int</li><li>修改ida安装目录下hexrays.cfg中的HO_IGNORE_OVERLAPS</li></ul></li></ul><p>7.<code> F5结果不正确</code></p><ul><li>成因：F5会自动删除其认为不可能到达的死代码</li><li>常见起因是一个函数错误的标注为noretur函数</li><li>解决方案<ul><li>进到目前反编译结果，找到最后被调用的函数(被错误分析的函数)，双击进入（迫使HexRays重新分析相应函数）</li><li>如果上述方案不成功，那么进到被错误分析的函数，按Tab切换到反汇编界面，按Alt+P进入界面取消函数的Does not return 属性</li></ul></li></ul><p>8.<code>local variable allocation failed</code></p><ul><li><p><strong>成因</strong>：</p><ul><li><p>分析函数 时，有部分变量对应的区域发生重叠，多见于ARM平台出现point rect等8字节，16字节，32字节结构时尤其多见。  </p></li><li><p>此错误消息意味着反编译器无法使用寄存器和堆栈位置分配本地变量。  </p></li><li><p>只有在配置文件中启用了HO_IGNORE_OVERLAPS之后，才会看到这个错误消息。如果输出中允许有重叠的变量，则以红色显示。</p></li></ul></li><li><p>解决方案：</p><ul><li>修改对应参数为多个int。  </li><li>更新函数堆栈帧并创建正确的堆栈变量也可以帮助解决这个问题。</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> f5报错 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>攻防世界re题目</title>
      <link href="/2025/01/27/gfsj/"/>
      <url>/2025/01/27/gfsj/</url>
      
        <content type="html"><![CDATA[<h1 id="攻防世界逆向题目"><a href="#攻防世界逆向题目" class="headerlink" title="攻防世界逆向题目"></a>攻防世界逆向题目</h1><h2 id="一、1000click"><a href="#一、1000click" class="headerlink" title="一、1000click"></a>一、1000click</h2><h3 id="思路一："><a href="#思路一：" class="headerlink" title="思路一："></a>思路一：</h3><p>点开程序后发现是游戏，点击1000下可以获得flag，利用CE可以破解游戏。  </p><p>打开程序  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250127005601.png">  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250127010341.png">  </p><p>click一下，修改数值，首次扫描。  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250127010551.png">  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250127010656.png" alt="首次扫描结果">  </p><p>随便click，输入click后的值再次扫描。  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250127010901.png">  </p><p>得到唯一的基址，双击基址添加它。  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250127010955.png">  </p><p>双击下面的数值更改它成999。 </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250127011150.png">  </p><p>最后点击程序click一下，得到flag  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250127011217.png">  </p><h3 id="思路二："><a href="#思路二：" class="headerlink" title="思路二："></a>思路二：</h3><p>利用ida静态分析。</p><p>点击程序check，出现error。  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250127011530.png">  </p><p>查壳发现是32位的无壳，拖入idax32。  </p><p>在字符串处查找error。  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250127011854.png">  </p><p>跟进，ctrl x交叉引用  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250127011919.png">  </p><p>向上划一下便得到flag。  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250127012058.png">  </p>]]></content>
      
      
      
        <tags>
            
            <tag> re题目wp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>启航杯rewp</title>
      <link href="/2025/01/26/qhctfwp/"/>
      <url>/2025/01/26/qhctfwp/</url>
      
        <content type="html"><![CDATA[<h2 id="rainbow"><a href="#rainbow" class="headerlink" title=".rainbow"></a>.rainbow</h2><h2 id="一、rainbow"><a href="#一、rainbow" class="headerlink" title="一、rainbow"></a>一、rainbow</h2><h3 id="1-查壳拖入ida"><a href="#1-查壳拖入ida" class="headerlink" title="1>查壳拖入ida"></a>1&gt;查壳拖入ida</h3><p>查看伪代码</p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126230527.png">  </p><p>点击跟进hide-flag。  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126230702.png">  </p><h3 id="2-分析代码"><a href="#2-分析代码" class="headerlink" title="2>分析代码"></a>2&gt;分析代码</h3><p>点开 xor_encrypt发现是简单的异或，分析得出flag异或后得到encryped-flag。  </p><p>打开output文件。  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126231110.png">  </p><h3 id="3-写脚本"><a href="#3-写脚本" class="headerlink" title="3>写脚本"></a>3&gt;写脚本</h3><p>发现是十六进制字符串，写代码把它转换成字节再进行异或即可得到flag。  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126231702.png">  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126231742.png">   </p><h2 id="二、小明的note"><a href="#二、小明的note" class="headerlink" title="二、小明的note"></a>二、小明的note</h2><h3 id="1-查壳拖入ida-1"><a href="#1-查壳拖入ida-1" class="headerlink" title="1>查壳拖入ida"></a>1&gt;查壳拖入ida</h3><p>upx -d脱壳，进入主函数查看伪代码。  </p><p><img src="/image%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126233934.png"></p><h3 id="2-分析伪代码"><a href="#2-分析伪代码" class="headerlink" title="2>分析伪代码"></a>2&gt;分析伪代码</h3><p>进入decryped_flag，发现是dest的异或，又是异或！并且v6又是十六进制字符，要转化为字节。  </p><p>a1是dest，即长度便是dest的长度</p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126235557.png">  </p><p>往前看发现unk_2010值赋给了dest，查看unk_2010。  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250127000135.png">  </p><h3 id="3-写脚本-1"><a href="#3-写脚本-1" class="headerlink" title="3>写脚本"></a>3&gt;写脚本</h3><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250127000517.png"></p><h2 id="三、checker"><a href="#三、checker" class="headerlink" title="三、checker"></a>三、checker</h2><p>查壳32位ida分析，跟进check_flag，跟进encrypt flag，发现又是异或。</p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250127001503.png">  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250127001534.png">  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250127001556.png">  </p><p>再查看encrypted_flag  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250127002011.png">  </p><p>写脚本  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250127002240.png">  </p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛re题目wp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆向破解010 Editor</title>
      <link href="/2025/01/22/010editor/"/>
      <url>/2025/01/22/010editor/</url>
      
        <content type="html"><![CDATA[<p>前几天做misc的时候发现010Editor试用期结束了，这回无论怎么卸载再安装也没法使用了，也找不到注册码，于是我想着逆向分析一下这个程序看能不能把他给破解了，多次尝试无果，于是上网查找相关资料，最后真的成功破解了！  </p><p>接下来记录一下这次破解过程：  </p><h2 id="一-明确思路："><a href="#一-明确思路：" class="headerlink" title="一.明确思路："></a>一.明确思路：</h2><p>破解010 Editor需要注册码，如果找不出注册码，只要始终把注册标志标记为已注册，就可以成功破解。  </p><p><img src="/image/010editor.png">  </p><h2 id="二-完整流程："><a href="#二-完整流程：" class="headerlink" title="二.完整流程："></a>二.完整流程：</h2><h3 id="1-下载010-Editor"><a href="#1-下载010-Editor" class="headerlink" title="1.下载010 Editor"></a>1.下载010 Editor</h3><p>从官网<a href="https://www.sweetscape.com/010editor/" title="官网">下载010 Editor</a>  </p><h3 id="2-固定PE基址"><a href="#2-固定PE基址" class="headerlink" title="2.固定PE基址"></a>2.固定PE基址</h3><p>我们在windows逆向时，经常会遇到PE文件的基地址随机的情况，不利于反汇编的对比分析，比如利用OD反汇编时的地址和<a href="https://www.52pojie.cn/thread-1874203-1-1.html">IDA</a>反汇编时就会有不同，两者在对比分析过程中就很难对应上。  </p><p>这时我们利用反汇编查壳神器<a href="https://down.52pojie.cn/?query=studype">study PE++ x64</a>来固定基址  </p><p>把exe拖入studype，点击固定PE基址，再点击文件保存更改。  </p><p><img src="/image/studype++.png">  </p><h3 id="3-拖入x64dbg分析"><a href="#3-拖入x64dbg分析" class="headerlink" title="3.拖入x64dbg分析"></a>3.拖入x64dbg分析</h3><h4 id="1-找程序入口："><a href="#1-找程序入口：" class="headerlink" title="1>找程序入口："></a>1&gt;找程序入口：</h4><p><img src="/image/x64dbgkaishi.png" alt="拖入后的界面">  </p><p>按F9运行程序直到出现程序入口(Entrypoint)，能看到一堆jmp指令。  </p><p><img src="/image/x64dbgentrypoint.png" alt="找到了程序入口">  </p><h4 id="2-找Evaluation-Version-n："><a href="#2-找Evaluation-Version-n：" class="headerlink" title="2>找Evaluation Version\n："></a>2&gt;找Evaluation Version\n：</h4><p>接下来找突破口：</p><p><strong>！！！重点</strong>：由于一打开010editor界面会出现<em><strong>Evaluation</strong></em>！  </p><p><img src="/image/010Editorkaishi.png">  </p><p>在程序入口按<strong>Shift + D</strong>，在当前模块进行字符搜索，输入<strong>Evaluation</strong>。  </p><p><img src="/image/x64dbgEvaluation.png">  </p><p>发现四个带有换行的Evaluation Version，这四个便是我们要找的（已设置断点(f2设置断点)的四个）。  </p><p>运行一下发现听到断点处，说明这段子程序就是在程序启动时用于检查注册状态的。  </p><h4 id="3-找注册标志："><a href="#3-找注册标志：" class="headerlink" title="3>找注册标志："></a>3&gt;找注册标志：</h4><p>选一个点进去发现他们都在同一个函数的下面。  </p><p><img src="/image/dainjidasimfocasmnviapsvni.png">  </p><p>向上翻找这个函数的头部。  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126170549.png" alt="子程序头部">  </p><p>点击这个子程序函数的第一条指令查看流程图。  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126170902.png">  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126171328.png" alt="流程图">  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126171420.png" alt="总览"></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmp   edi,DB</span><br><span class="line">jne   010editor.140392FC0 // 结果不为零（或不相等）的情况下进行跳转</span><br></pre></td></tr></tbody></table></figure><blockquote><p>通过分析流程图可知，子程序流程在这里分成两个方向：EAX = 0xDB，表示各种已注册的状态，EAX &lt;&gt; 0xDB，表示各种未注册状态。由此可知，EAX = 0xDB是成功注册标志。  </p><p>找到注册标志后，改程序流向是无效的，必须找到设置注册标志的公共CALL，在CALL里边改程序流向，才能真正实现破解。</p><p>在这个程序中，判断注册标志指令是cmp edi, 0xDB，它上面的CALL是一个模块外的系统子程序调用，再往上没有CALL了，怎么办？这说明这个标志已经提前由真正的CALL算好了，下面的关键是怎么找到这个真正的CALL</p></blockquote><hr><ul><li><p><strong>cmp指令</strong>的使用和理解：  </p><p><em><strong>cmp指令</strong></em>是汇编语言中用于比较两个操作数的大小的指令。它执行的是一个隐含的减法操作，即从目的操作数中减去源操作数，但不会改变任何操作数的值。CMP指令的结果会影响处理器的标志位，这些标志位随后可以用于条件跳转指令。</p></li></ul><p>两个<strong>无符号数</strong>的比较：</p><table><thead><tr><th>CMP结果</th><th>ZF</th><th>CF</th></tr></thead><tbody><tr><td>目的操作数 ＜ 源操作数</td><td>0</td><td>1</td></tr><tr><td>目的操作数 ＞ 源操作数</td><td>0</td><td>0</td></tr><tr><td>目的操作数 = 源操作数</td><td>1</td><td>0</td></tr></tbody></table><p>两个<strong>有符号数</strong>的比较：</p><table><thead><tr><th>CMP结果</th><th>标志位</th></tr></thead><tbody><tr><td>目的操作数 ＜ 源操作数</td><td>SF ≠ OF</td></tr><tr><td>目的操作数 ＞ 源操作数</td><td>SF = OF</td></tr><tr><td>目的操作数 = 源操作数</td><td>ZF = 1</td></tr></tbody></table><ul><li><p><em><strong>jnz</strong></em>指令：</p><p><strong>JNZ</strong> 指令，全称为 <strong>Jump if Not Zero</strong>，是汇编语言中的条件转移指令。这条指令的作用是在结果不为零（或不相等）的情况下进行跳转。 </p></li><li><p><em><strong>jz</strong></em>指令</p><p>与之相对的是 <strong>JZ</strong> 指令，它在结果为零时触发跳转。在实际编程中，<strong>JNZ</strong> 通常与比较指令 <strong>CMP</strong> 或测试指令 <strong>TEST</strong> 结合使用，以根据比较或测试的结果决定程序的执行流程。</p></li></ul><hr><h4 id="4-找真正的call"><a href="#4-找真正的call" class="headerlink" title="4>找真正的call"></a>4&gt;找真正的call</h4><p>接下来脱离流程图。  </p><p>找到并选中代表<strong>注册标志</strong>的指令：cmp edi,D8  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126181532.png">  </p><p>复制他的二进制指令码，并在当前模块进行<strong>匹配特征搜索</strong>，查找所有的注册标志指令。  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126181949.png" alt="复制二进制指令码">  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126182205.png" alt="匹配特征搜索">  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126182316.png" alt="粘贴二进制码搜索">  </p><p>结果只有一个  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126182434.png">  </p><p>之后上网搜索发现使用了别的寄存器：</p><p><code>cmp eax,DB // 3D DB 00 00 00 </code>  </p><p>重新搜索匹配特征  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126183108.png" alt="3D DB 00 00 00">  </p><p>得到七个结果。  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126183330.png" alt="结果"> </p><p>挨个点击去查看  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126183632.png">  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126183731.png">   </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126183830.png">  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126183950.png">  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126184022.png">  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126184046.png">  </p><p>发现四个代码中都出现了<code>ca11 010editor.140007630</code>，所以是这个call影响了寄存器eax的值，是<em><strong>真正的call</strong></em>！    </p><p>持续跟进这个call的代码段  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126184907.png" alt="跟进">  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126184933.png" alt="再跟进">  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126184948.png" alt="最终子程序的代码段">  </p><h4 id="5-修改注册标志"><a href="#5-修改注册标志" class="headerlink" title="5>修改注册标志"></a>5&gt;修改注册标志</h4><p>由图可知这个子程序出口有很多，只要把eax的值修改为0xD8即可注册成功。  </p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">74 10          je 010editor.140392A95  </span><br><span class="line">B8 13010000    mov eax,113  </span><br></pre></td></tr></tbody></table></figure><p>修改为  </p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">74 00          je 010editor.140392A85  </span><br><span class="line">B8 DB000000    eax,DB</span><br></pre></td></tr></tbody></table></figure><p>修改前  </p><p><img src="/iamge/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126192129.png" alt="修改前">  </p><p>右键，点二进制，点编辑（Ctrl + E）,先修改je跳转，防止他乱赋值。   </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126192244.png" alt="二进制，编辑">  </p><p>修改后为  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126192543.png" alt="修改后">   </p><p>Ctrl + P或者右键，补丁，修补文件。  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126193751.png">  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126194006.png">  </p><p>发现无法修补文件</p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126194035.png">  </p><p>用IDA进行逆向，再修改Assembly（安装keypatch插件）  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126194359.png">   </p><p>发现encode值为···，点击Patch后无法修改。  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126194725.png">  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126194750.png">  </p><blockquote><p>这种情况只能通过kstool工具(支持很多架构)(git上)，手动去翻译汇编指令称机器码然后手动填写可以完成patch  </p></blockquote><blockquote><p>-&gt;&gt;kstool arm64 “需要翻译的汇编指令” [指令所在的地址]<br>-&gt;&gt;得到机器码</p></blockquote><p>由于之前我们在x64dbg修改过，得到了指令对应的机器码。  </p><h4 id="6-保存修改的补丁"><a href="#6-保存修改的补丁" class="headerlink" title="6>保存修改的补丁"></a>6&gt;保存修改的补丁</h4><p>右键机器码，点Patching，点Change byte…直接更改   </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126200251.png" alt="change byte"></p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126195802.png" alt="修改前">  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126200053.png" alt="修改后">  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126200204.png" alt="修改后">  </p><p>右键Edit，Program，Apply Patches to…来保存  </p><p><img src="/iamge/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126200449.png">   </p><h4 id="7-成功逆向"><a href="#7-成功逆向" class="headerlink" title="7>成功逆向"></a>7&gt;成功逆向</h4><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126200942.png">  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126201302.png" alt="成功打开"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 010 Editor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web学习记录</title>
      <link href="/2025/01/19/webknow/"/>
      <url>/2025/01/19/webknow/</url>
      
        <content type="html"><![CDATA[<h2 id="一、万能密码"><a href="#一、万能密码" class="headerlink" title="一、万能密码"></a>一、万能密码</h2><p><strong>万能密码：’ or ‘=’ #</strong><br>select * from user where username=’’or ‘=’#’ and password=’ ‘（*是通配符，#注释掉后面的语句，or前面是空的，为假，后面为真的，又因为是or语句，所以总体为真。）<br>（除了 # 以外， – 也是SQL中的注释符，但SQL的语法格式规定–和后面的注释内容必须间隔一个空格，所以这需要使用 a’ or 1 – a 而不是 a’ or 1 – 其原理和 a’ or 1 # 大同小异）     </p><h2 id="二、SQL注入"><a href="#二、SQL注入" class="headerlink" title="二、SQL注入"></a>二、SQL注入</h2><h3 id="1-SQL注入的分类："><a href="#1-SQL注入的分类：" class="headerlink" title="1.SQL注入的分类："></a>1.SQL注入的分类：</h3><p>1.根据注入位置分类：get、post、head头注入</p><ol start="2"><li><p>根据反馈结果分类：有回显（显错注入）、无回显（盲注）</p></li><li><p>根据数据类型分类：<br>                           1.数字型：0123456789<br>                           2.字符型：输入的参数为字符串。<br><em><strong>最大的区别</strong></em>：字符型不需要闭合，字符串型一般需要闭合。 </p><h3 id="2-SQL注入的流程："><a href="#2-SQL注入的流程：" class="headerlink" title="2.SQL注入的流程："></a>2.SQL注入的流程：</h3><p>？id=1asdfg  </p><h4 id="一、看是否报错："><a href="#一、看是否报错：" class="headerlink" title="一、看是否报错："></a>一、看是否报错：</h4><p>1.不报错：字符型</p><ol start="2"><li><p>报错：数字型</p><h4 id="二、看是什么闭合类型"><a href="#二、看是什么闭合类型" class="headerlink" title="二、看是什么闭合类型"></a>二、看是什么闭合类型</h4><p>id=1asdfg’（看回显，判断闭合方式）</p><p>id=1asdfg’  –+（注释掉后面内容，使运行正常，相当于– ）</p></li></ol><h4 id="三、判断列数：order-by"><a href="#三、判断列数：order-by" class="headerlink" title="三、判断列数：order by"></a>三、判断列数：order by</h4><p>?id=1asdfg’  order by 3（自己试–+</p><h4 id="四、查询回显到屏幕上的列"><a href="#四、查询回显到屏幕上的列" class="headerlink" title="四、查询回显到屏幕上的列"></a>四、查询回显到屏幕上的列</h4><p>?id=-1asdfg’ union select 1,2,3（查询出来是几列就填几)–+<br>（1改成-1，为了让页面显示出来查询的1，2，3，要让前面查询不出内容。）<br>（得到查询出来的回显位）</p><h4 id="五、获取数据名称-security"><a href="#五、获取数据名称-security" class="headerlink" title="五、获取数据名称   security"></a>五、获取数据名称   security</h4><p>?id=-1asdfg’ union select 1,database(),3–+</p><h4 id="六、获取表名-emails-referers-uagents-users"><a href="#六、获取表名-emails-referers-uagents-users" class="headerlink" title="六、获取表名     emails,referers,uagents,users"></a>六、获取表名     emails,referers,uagents,users</h4><p>?id=-1’ union select 1,(select group_concat(table_name) from information_schema.tables where table_schema=’security’),3–+</p><p>（information_schema数据库是MySQL5.0以上自带的）</p><h4 id="七、获取users表的列名-id，username，password"><a href="#七、获取users表的列名-id，username，password" class="headerlink" title="七、获取users表的列名    id，username，password"></a>七、获取users表的列名    id，username，password</h4><p>?id=-1’ union select 1,(select group_concat(column_name) from information_schema.columns where table_schema=’security’ and table_name=’users’),3–+</p><h4 id="八、获取username具体的数据"><a href="#八、获取username具体的数据" class="headerlink" title="八、获取username具体的数据"></a>八、获取username具体的数据</h4><p>?id=-1’ union select 1,(select group_concat(username) from users),3–+</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> web学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDA超全使用方法</title>
      <link href="/2025/01/14/my-first-blog/"/>
      <url>/2025/01/14/my-first-blog/</url>
      
        <content type="html"><![CDATA[<h1 id="一、IDA的下载"><a href="#一、IDA的下载" class="headerlink" title="一、IDA的下载"></a>一、IDA的下载</h1><p>ida的官网下载地址<a href="https://hex-rays.com/ida-free#download" title="ida官网">ida下载</a>，包含x64和x32.   </p><p>也可以在52破解上下载。</p><h1 id="二、IDA的介绍及如何使用"><a href="#二、IDA的介绍及如何使用" class="headerlink" title="二、IDA的介绍及如何使用"></a>二、IDA的介绍及如何使用</h1><h2 id="1-IDA简介"><a href="#1-IDA简介" class="headerlink" title="1.IDA简介"></a>1.IDA简介</h2><p>IDA，全称为<strong>交互式反汇编器专业版</strong>（Interactive Disassembler  Professional），是一款功能强大的静态反编译软件。它被广泛用于软件安全分析，尤其是在0day研究和ShellCode分析中不可或缺。IDA  Pro以其交互性、可编程性、可扩展性以及对多处理器的支持而闻名，能够在Windows、Linux、WinCE、MacOS等多个平台上运行，分析各种程序代码。  </p><p>IDA Pro支持多种CPU指令集，包括但不限于Intel  x86、x64、MIPS、PowerPC、ARM、Z80、68000和c8051。这使得IDA  Pro能够分析各种不同架构的程序，成为逆向工程领域的重要工具。IDA  Pro的递归下降反汇编能力，以及其在区分代码和数据、确定数据类型方面的高效算法，使得它能够提供接近源代码的反汇编输出。 </p><h2 id="2-在IDA中打开文件"><a href="#2-在IDA中打开文件" class="headerlink" title="2.在IDA中打开文件"></a>2.在IDA中打开文件</h2><blockquote><p><em>双击</em>ida  </p></blockquote><p><img src="/image/idajiemian.png" alt="ida"></p><blockquote><p><strong>new</strong>会打开一个空白页面，把想逆向的文件拖进去即可，或者点击<strong>go</strong>直接去打开文件。 </p></blockquote><p><img src="/image/buzhouwenjian1.png" alt="ida">  </p><h2 id="3-界面简介"><a href="#3-界面简介" class="headerlink" title="3.界面简介"></a>3.界面简介</h2><p> 打开后如下界面  </p><p><img src="/image/jiemianjieshao1.png" alt="界面简介">    </p><hr><h3 id="界面各个窗口介绍"><a href="#界面各个窗口介绍" class="headerlink" title="界面各个窗口介绍"></a>界面各个窗口介绍</h3><ul><li><p><em><strong>导航条</strong></em>的<strong>含义</strong>：</p><p>蓝色：表示常规的指令函数，绝大部分为用户编写的代码，上图中绝大部分数据属于蓝色数据。 </p><p>黑色：表示间隙部分内容，可执行文件中包含多个节段，相邻节段之间存在空隙，红色表示空隙部分。 </p><p>银白色：表示数据项部分内容，可执行文件中会包含大量数据，银白色表示数据项部分内容。 </p><p>粉色：表示外部导入符号，通常可执行文件会导入外部的库函数。 </p><p>暗黄色：表示IDA未识别的内容，需要用户根据需求自行分析。  </p></li><li><p><em><strong>IDA View</strong></em>（反汇编窗口）的<strong>含义</strong>：  </p><p>包括三种反汇编视图:文本视图、图表视图、路径视图。  </p><p>反汇编窗口属于逆向分析过程中关注频率最高的窗口，通过此窗口可以逆向分析反汇编代码。  </p></li><li><p><em><strong>Hex View</strong></em>的<strong>含义</strong>：  </p><p>二进制查看窗口总共分为三部分，三部分内容分别位于上图左、中、右，三处含义分别为：  </p><p>左边数据：表示二进制数据对应的内存相对偏移。  </p><p>中间数据：表示内存中数据的具体内容。  </p><p>右边数据：表示内存数据的字符串显示，该功能可辅助读者快速识别字符串内容。  </p><p>用户可在二进制查看窗口中编辑二进制数据，从而满足篡改数据的测试需求。  </p><p><img src="/image/view.png" alt="图标视图中红黄蓝线的应用">   </p></li><li><p><em><strong>Structures</strong></em>的<strong>含义</strong>：  </p><p>结构窗口提供用户查询已定义的结构体，同时IDA可识别出可执行文件包含的部分结构体数据，结构窗口可通过快捷键“+”、“-”展开和收缩结构体，IDA结构窗口支持用户自定义结构体。  </p></li><li><p><em><strong>Imports</strong></em>的<strong>含义</strong>：  </p><p>IDA提供导入函数窗口，用于可在导入函数窗口中查看当前可执行文件导入哪些外部函数库及函数，通过导入函数窗口可获取到函数内存相对偏移地址、函数名、导入函数所属的库文件。  </p></li><li><p><em><strong>Exports</strong></em>的<strong>含义</strong>：  </p><p>IDA的导出函数窗口提供可执行文件导出函数信息，通过导出函数窗口可获取到导出的函数名、函数对应的内存相对偏移地址。  </p></li><li><p><em><strong>Function</strong></em>的<strong>含义</strong>：</p><p>IDA提供函数窗口供玩家查找函数信息，在窗口按下“CTRL + F”快捷键便可根据需求搜索函数名，快速定位函数名方式可提供逆向分析效率。  </p></li><li><p><em><strong>Enum</strong></em>的<strong>含义</strong>：  </p><p>枚举窗口。   </p><h2 id="4-快捷键详细介绍"><a href="#4-快捷键详细介绍" class="headerlink" title="4.快捷键详细介绍"></a>4.快捷键详细介绍</h2><table><thead><tr><th align="center"><strong>快捷键</strong></th><th align="center"><strong>功能说明</strong></th></tr></thead><tbody><tr><td align="center">空格键(space)</td><td align="center">反汇编窗口切换文本与图形</td></tr><tr><td align="center">Enter</td><td align="center">跟进函数实现，查看标号对应的地址</td></tr><tr><td align="center"><strong>Esc</strong></td><td align="center">在反汇编窗口中使用为后退到上个操作的地址处</td></tr><tr><td align="center"><strong>A</strong></td><td align="center">将选择的信息转换成ASCII(转换成可读性跟强的字符串)</td></tr><tr><td align="center">B</td><td align="center">十六进制与二进制数转换</td></tr><tr><td align="center">C</td><td align="center">解释光标处的地址为一条指令（代码）</td></tr><tr><td align="center">D</td><td align="center">解释光标处的地址为数据，每按一次将会转换这个地址的数据长度</td></tr><tr><td align="center">G</td><td align="center">跳转到指定地址</td></tr><tr><td align="center">H</td><td align="center">十六进制与十进制数转换</td></tr><tr><td align="center">K</td><td align="center">将数据解释为栈变量</td></tr><tr><td align="center">M</td><td align="center">解释为枚举成员（转换为枚举类型常量）</td></tr><tr><td align="center">N</td><td align="center">对符号重新命名</td></tr><tr><td align="center">O</td><td align="center">解释地址为数据段偏移量，用于字符串标号</td></tr><tr><td align="center">P</td><td align="center">创建函数</td></tr><tr><td align="center">R</td><td align="center">将ASCII转换为字符</td></tr><tr><td align="center">T</td><td align="center">解释数据为一个结构体成员（解析结构体偏移）</td></tr><tr><td align="center">U（indefine）</td><td align="center">取消定义光标处函数、代码、数据的定义</td></tr><tr><td align="center">X</td><td align="center">转换视图到交叉参考模式</td></tr><tr><td align="center">Y</td><td align="center">设置变量类型</td></tr><tr><td align="center"><strong>/</strong></td><td align="center">伪代码中进行注释</td></tr><tr><td align="center"><strong>:</strong></td><td align="center">光标所在位置添加<strong>常规注释</strong>和可重复注释</td></tr><tr><td align="center"><strong>F2</strong></td><td align="center">设置断点（F2在十六进制窗口进行修改，然后再按F2应用）</td></tr><tr><td align="center">F4</td><td align="center">运行到光标所在处（可用于跳出循环）</td></tr><tr><td align="center">F5</td><td align="center">查看伪代码</td></tr><tr><td align="center">F7</td><td align="center">单步步进</td></tr><tr><td align="center">F9</td><td align="center">动态调试程序(其实IDA主要用作静态分析用的)</td></tr><tr><td align="center">F10</td><td align="center">打开反汇编选项菜单快捷键</td></tr><tr><td align="center">F12</td><td align="center">暂时停止</td></tr><tr><td align="center">Ctrl+F2</td><td align="center">重新开始</td></tr><tr><td align="center">Art+F2</td><td align="center">结束跟踪</td></tr><tr><td align="center">Ctrl+F7</td><td align="center">自动步入，在所有的函数调用中一条一条地执行命令，断点或异常时，自动 停止</td></tr><tr><td align="center"><strong>Shift + E</strong></td><td align="center">提取数据</td></tr><tr><td align="center"><strong>Shift</strong> + F5</td><td align="center">打开签名窗口</td></tr><tr><td align="center">Shift + F9</td><td align="center">添加结构体</td></tr><tr><td align="center">Shift + F12</td><td align="center">自动分析出参考字符串</td></tr><tr><td align="center"><strong>Ctrl</strong> + F</td><td align="center">搜索字符串</td></tr><tr><td align="center">Ctrl + M</td><td align="center">查看标签（列举出当前已经添加的标签）</td></tr><tr><td align="center">Ctrl + S</td><td align="center">查看段的信息（列举出二进制程序的段的开始地址、结束地址、权限等信息）</td></tr><tr><td align="center">Ctrl + X</td><td align="center">交叉引用,类似于OD中的栈回溯操作</td></tr><tr><td align="center">Ctrl + F9</td><td align="center">导入c头文件</td></tr><tr><td align="center">CTRL + F12</td><td align="center">函数调用图</td></tr><tr><td align="center"><strong>Alt+T</strong></td><td align="center">搜索字符串(文本搜索)(可用于搜索main函数)</td></tr><tr><td align="center">Alt+B</td><td align="center">搜索十六进制（用于搜索十六进制字节序列，通常在分析过程中可以用来搜索opcode）</td></tr><tr><td align="center">Alt+G</td><td align="center">转换局部变量为结构体</td></tr><tr><td align="center">Alt+L</td><td align="center">标记(Label)</td></tr><tr><td align="center">ALT + M</td><td align="center">添加标签(mark)</td></tr><tr><td align="center">Ctrl+Shift+W</td><td align="center">拍摄IDA快照</td></tr><tr><td align="center">view–&gt;open subviews</td><td align="center">可以恢复你无意中关闭的数据显示窗口</td></tr><tr><td align="center">windows–&gt;reset desktop</td><td align="center">可以恢复初始ida布局</td></tr><tr><td align="center">option–&gt;font</td><td align="center">option–&gt;font</td></tr><tr><td align="center">option–&gt;general-&gt;Auto comments</td><td align="center">自动添加反汇编注释</td></tr></tbody></table><h2 id="5-判断IDA分析可执行文件完毕的三种方法"><a href="#5-判断IDA分析可执行文件完毕的三种方法" class="headerlink" title="5.判断IDA分析可执行文件完毕的三种方法"></a>5.判断IDA分析可执行文件完毕的三种方法</h2><p>1.图中IDA的“Output Window”窗口输出“The initial autoanalysis has been<br> finished”日志时，则说明IDA已分析完毕。  </p><p>2.如图所示进度条处黄色向上箭头消失时，则表明IDA分析完毕。  </p><p>3.图中IDA界面左下角AU处于”idle”状态时，也表明IDA分析完毕。</p></li></ul><h1 id="三、用IDA分析程序实例"><a href="#三、用IDA分析程序实例" class="headerlink" title="三、用IDA分析程序实例"></a>三、用IDA分析程序实例</h1><h2 id="1-查壳"><a href="#1-查壳" class="headerlink" title="1.查壳"></a>1.查壳</h2><ul><li><p>使用exeinfo pe<a href="https://www.52pojie.cn/thread-1837928-1-1.html">52破解</a>查壳看他是64位还是32位的程序或者其他类型的如ELF等，以便于事后进行分析。  </p></li><li><p>或者使用peid来进行查壳<a href="https://www.softpedia.com/get/Programming/Packers-Crypters-Protectors/PEiD-updated.shtml">peid官网地址</a>。   </p><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p><img src="/image/easy64.png" alt="程序easy-64">  </p><p>拖入exeinfope后如图  </p><p><img src="/image/exeinfope.png" alt="壳"></p><p>得到程序为ELF类型的。  </p><h2 id="2-用IDA进行分析"><a href="#2-用IDA进行分析" class="headerlink" title="2.用IDA进行分析"></a>2.用IDA进行分析</h2><p>拖入IDA打开后点击main函数进行查看  </p><p>由于对于汇编代码不熟悉，点击tab键进入伪代码。  </p><p><img src="/image/easy64ida.png" alt="ida分析">  </p><p><img src="/image/easy64flag.png" alt="伪代码">  </p><p>由此我们得到了flag</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> IDA教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/01/14/hello-world/"/>
      <url>/2025/01/14/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
