<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>常见函数用法</title>
      <link href="/2025/07/03/chang-jian-han-shu-yong-fa/"/>
      <url>/2025/07/03/chang-jian-han-shu-yong-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="常见函数用法"><a href="#常见函数用法" class="headerlink" title="常见函数用法"></a>常见函数用法</h1><h2 id="1-read"><a href="#1-read" class="headerlink" title="1.read"></a>1.<em><strong>read</strong></em></h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span>(0, buf, 0xAuLL);</span><br></pre></td></tr></tbody></table></figure><p>用法：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssize_t <span class="built_in">read</span>(int fd, void *buf, size_t count);</span><br><span class="line">bash</span><br></pre></td></tr></tbody></table></figure><p>参数解释：</p><blockquote><p>fd：文件描述符，表示要读取的文件或者输入源。在 UNIX 系统中，0 表示标准输入(STDIN)，1 表示标准输出(STDOUT)，2 表示标准错误(STDERR)。</p><ul><li>文件描述符0：用于接收用户输入或者从管道、重定向或者其他输入源读取数据。</li><li>文件描述符1：用于向终端或者其他输出目标输出数据。</li></ul><p>buf：指向存储读取数据的缓冲区的指针。</p><p>count：要读取的最大字节数。</p></blockquote><p>注：0xAuLL 中的 uLL 表示这是一个无符号长长整型(unsigned long long)的常量，sleep(0x1BF52u)中的u表示无符号整型(unsigned)。</p><h2 id="2-strcat"><a href="#2-strcat" class="headerlink" title="2.strcat"></a>2.<em><strong>strcat</strong></em></h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strcat(dest, buf);</span><br></pre></td></tr></tbody></table></figure><p>这行代码将用户输入的内容追加到 dest 字符串后面</p><p>双击跟进 dest</p><p>可以看到 dest 被声明为一个大小为 4 字节的字符数组，用来存储字符串</p><p>详细解释：</p><pre><code>dest 是一个标签（label），它是程序中一个位置的名称或者符号。db 是汇编语言中的伪指令（pseudo-instruction），用于声明字节（byte）类型的数据。4 表示数组的大小为4字节。dup(?) 表示重复（duplicate）未知值（?）4次，即将4个未知值（通常为0）依次填充到数组中。</code></pre><p><img src="/image/766e383b3bc7bcc635bdf609ee167f9.png"></p><h2 id="3-setvbuf"><a href="#3-setvbuf" class="headerlink" title="3.setvbuf"></a>3.<em><strong>setvbuf</strong></em></h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>C 库函数 <strong>int setvbuf(FILE *stream, char *buffer, int mode, size_t size)</strong> 定义流 stream 应如何缓冲。</p><p>stream： 指向需要设置缓冲区的流（stdin，stdout）</p><p>buf： 指向缓冲区的指针。</p><p>mode： 表示缓冲方式，值为0表示全缓冲（只有缓冲区填满才会输出）；值为1表示行缓冲（当遇到换行符或缓冲区满时输出）；值为2表示无缓冲（数据直接输出）。</p><p>size： 表示缓冲区大小。</p><p>返回值： 如果返回0表示函数调用成功，缓冲区设置成功。反之，函数调用失败。</p><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>下面是 setvbuf() 函数的声明。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int setvbuf(FILE *stream, char *buffer, int mode, size_t size)</span><br></pre></td></tr></tbody></table></figure><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul><li><strong>stream</strong> – 这是指向 FILE 对象的指针，该 FILE 对象标识了一个打开的流。</li><li><strong>buffer</strong> – 这是分配给用户的缓冲。如果设置为 NULL，该函数会自动分配一个指定大小的缓冲。</li><li><strong>mode</strong> – 这指定了文件缓冲的模式：</li></ul><table><thead><tr><th>模式</th><th>描述</th></tr></thead><tbody><tr><td>_IOFBF</td><td><strong>全缓冲</strong>：对于输出，数据在缓冲填满时被一次性写入。对于输入，缓冲会在请求输入且缓冲为空时被填充。</td></tr><tr><td>_IOLBF</td><td><strong>行缓冲</strong>：对于输出，数据在遇到换行符或者在缓冲填满时被写入，具体视情况而定。对于输入，缓冲会在请求输入且缓冲为空时被填充，直到遇到下一个换行符。</td></tr><tr><td>_IONBF</td><td><strong>无缓冲</strong>：不使用缓冲。每个 I/O 操作都被即时写入。buffer 和 size 参数被忽略。</td></tr></tbody></table><ul><li><strong>size</strong> –这是缓冲的大小，以字节为单位。</li></ul><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>如果成功，则该函数返回 0，否则返回非零值。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>下面的实例演示了 setvbuf() 函数的用法。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">   <span class="type">char</span> buff[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">   <span class="built_in">memset</span>( buff, <span class="string">'\0'</span>, <span class="keyword">sizeof</span>( buff ));</span><br><span class="line"></span><br><span class="line">   <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"启用全缓冲\n"</span>);</span><br><span class="line">   setvbuf(<span class="built_in">stdout</span>, buff, _IOFBF, <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"这里是 runoob.com\n"</span>);</span><br><span class="line">   <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"该输出将保存到 buff\n"</span>);</span><br><span class="line">   fflush( <span class="built_in">stdout</span> );</span><br><span class="line"></span><br><span class="line">   <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"这将在编程时出现\n"</span>);</span><br><span class="line">   <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"最后休眠五秒钟\n"</span>);</span><br><span class="line"></span><br><span class="line">   sleep(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>让我们编译并运行上面的程序，这将产生以下结果。在这里，程序把缓冲输出保存到 <strong>buff</strong>，直到首次调用 <strong>fflush()</strong> 为止，然后开始缓冲输出，最后休眠 5 秒钟。它会在程序结束之前，发送剩余的输出到 STDOUT。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">启用全缓冲</span><br><span class="line">这里是 runoob.com</span><br><span class="line">该输出将保存到 buff</span><br><span class="line">这将在编程时出现</span><br><span class="line">最后休眠五秒钟</span><br></pre></td></tr></tbody></table></figure><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><img src="/image/0e853309ca5b5902106461f8a1a2619.png"></p><p><img src="/image/7714687b04bb989aa63673edc27efb7.png"></p><p>  <code>v5 = __readfsqword(0x28u);</code></p><pre><code>从线程本地存储 (FS segment) 的 0x28 偏移读取栈 canary（栈保护机制）；如果栈被溢出破坏，函数返回前会检查这个值是否被改动，如果改变就会触发异常/崩溃。</code></pre><p> <code> setvbuf(_bss_start, 0LL, 2, 0LL);</code></p><p>✅ 重点：这句很不常见！</p><pre><code>通常：setvbuf(stdout, NULL, _IONBF, 0) 用来设置 stdout 的缓冲模式。但这里设置的是 _bss_start，这是**.bss 段的起始地址**，不应该是 FILE 指针！</code></pre><p>说明：这行是为了造成混淆或隐藏 stdout 的关闭行为，你会发现这实际上等价于关闭了 stdout，或至少破坏了它的使用。</p><p>类似行为在前文提到的：</p><p><code>fclose(_bss_start);</code></p><p>也是一样的意图。</p><p>所以：</p><pre><code>这句话的目的其实是 使程序不能正常通过 printf/puts 输出结果，增加难度。</code></pre><p>  <code>setvbuf(stdin, 0LL, 1, 0LL);</code></p><pre><code>关闭 stdin 的缓冲，使得输入行为是行缓冲或无缓冲；这让输入变得更实时，对交互有帮助。</code></pre><h4 id="构造方法："><a href="#构造方法：" class="headerlink" title="构造方法："></a>构造方法：</h4><p><code>cat /ctf* 1&gt;&amp;0</code></p><h5 id="1-0是什么意思？"><a href="#1-0是什么意思？" class="headerlink" title="1>&amp;0是什么意思？"></a>1&gt;&amp;0是什么意思？</h5><blockquote><p>这是 Bash 的 <strong>文件描述符重定向语法</strong>，意思是：把 <strong>标准输出（1）</strong> 重定向到 <strong>标准输入（0）</strong></p></blockquote><blockquote><p>也就是说：</p><ul><li><code>cat</code> 原本写入 <strong>stdout</strong></li><li>现在 <code>stdout</code> 被重定向到了 <code>stdin</code>，而你还可以通过 <code>stdin</code> 接收数据（比如和程序交互时）</li></ul></blockquote><h5 id="为什么这样能显示出-flag？"><a href="#为什么这样能显示出-flag？" class="headerlink" title="为什么这样能显示出 flag？"></a>为什么这样能显示出 flag？</h5><blockquote><ul><li>虽然 <code>stdout</code> 被程序关闭或破坏了，但 <code>stdin</code>（描述符 0）还在；</li><li>通过 <code>1&gt;&amp;0</code>，让 <code>cat</code> 输出重定向到你还能“看见”的地方；</li><li>因为你是通过 <code>read</code> + <code>system(buf)</code> 执行命令，这个子进程的输出其实是能从 stdin 中读到的；</li><li>很多 CTF 沙箱中使用 pseudo terminal / 父进程通信 / pipe 来连接 stdin/stdout，所以这样能“绕过关闭 stdout”的限制。</li></ul></blockquote><h2 id="4-fork"><a href="#4-fork" class="headerlink" title="4.fork"></a>4.fork</h2><h4 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h4><p><img src="/image/7714687b04bb989aa63673edc27efb7.png"></p><p>fork开启了一个全新的进程，返回两次返回值，父进程返回子进程的PID，子进程返回值为0（如果出现错误，fork返回一个负值）,题目中当fork被调用，先是父进程返回值，因此PID＞0，执行if下面的代码，wait（0LL）执行，父进程堵塞，等待子进程结束，<strong>父进程将被挂起</strong>，直到子进程完成，sleep(3u)是等待3s。此时的子进程中，fork返回0，进入else，关闭了输出流，然后从标准输入中读取了32个字节到buf，然后执行system(&amp;buf)。</p><blockquote><p>引用一位网友的话来解释fpid的值为什么在父子进程中不同。“其实就相当于链表，进程形成了链表，父进程的fpid(p 意味point)指向子进程的进程id, 因为子进程没有子进程，所以其fpid为0.</p></blockquote><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>很多 CTF 沙箱中使用 pseudo terminal / 父进程通信 / pipe 来连接 stdin/stdout，所以这样能“绕过关闭 stdout”的限制。</p><hr><p><a href="https://blog.csdn.net/2301_80976241/article/details/144294553?fromshare=blogdetail&amp;sharetype=blogdetail&amp;sharerId=144294553&amp;sharerefer=PC&amp;sharesource=2301_80976241&amp;sharefrom=from_link">流的理解，setvbuf函数</a></p><p><a href="https://www.runoob.com/cprogramming/c-function-setvbuf.html">C 库函数 - setvbuf()</a></p><p><a href="https://blog.csdn.net/Sunnyside_/article/details/108196543">【Linux】fork()函数详解 (深入浅出 实例讲解)</a></p><p><a href="https://blog.csdn.net/jixianghahaxiao/article/details/45717953">Linux中fork（）函数详解 父子进程变量的关系</a></p><p><a href="https://www.runoob.com/cprogramming/c-function-system.html">C 库函数 - system()</a></p><p><a href="https://blog.csdn.net/Myon5/article/details/137891670">CTFshow-PWN-前置基础（pwn18-pwn19）</a></p><p><a href="https://blog.csdn.net/2301_80976241/article/details/144295269">CTFshow-pwn入门-前置基础pwn13-pwn19</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寄存器寻址方式</title>
      <link href="/2025/07/03/ji-cun-qi-xun-zhi-fang-shi/"/>
      <url>/2025/07/03/ji-cun-qi-xun-zhi-fang-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="寄存器寻址"><a href="#寄存器寻址" class="headerlink" title="寄存器寻址"></a>寄存器寻址</h1><p>section .data<br>    msg db “Welcome_to_CTFshow_PWN”, 0</p><p>section .text<br>    global _start</p><p>_start:</p><p>; 立即寻址方式<br>    mov eax, 11         ; 将11赋值给eax<br>    add eax, 114504     ; eax加上114504<br>    sub eax, 1          ; eax减去1</p><p>; 寄存器寻址方式<br>    mov ebx, 0x36d      ; 将0x36d赋值给ebx<br>    mov edx, ebx        ; 将ebx的值赋值给edx</p><p>; 直接寻址方式<br>    mov ecx, msg      ; 将msg的地址赋值给ecx**（找msg的地址）**。</p><p>; 寄存器间接寻址方式<br>    mov esi, msg        ; 将msg的地址赋值给esi<br>    mov eax, [esi]      ; 将esi所指向的地址的值赋值给eax**（等于找msg地址存储的值）**。</p><p>; 寄存器相对寻址方式<br>    mov ecx, msg        ; 将msg的地址赋值给ecx<br>    add ecx, 4          ; 将ecx加上4<br>    mov eax, [ecx]      ; 将ecx所指向的地址的值赋值给eax**（ecx加上4后的值作为地址，他指向的值再赋给eax）**。</p><p>; 基址变址寻址方式<br>    mov ecx, msg        ; 将msg的地址赋值给ecx<br>    mov edx, 2          ; 将2赋值给edx<br>    mov eax, [ecx + edx<em>2]  ; 将ecx+edx</em>2所指向的地址的值赋值给eax**（将ecx+edx*2的值作为地址）**。</p><p>; 相对基址变址寻址方式<br>    mov ecx, msg        ; 将msg的地址赋值给ecx<br>    mov edx, 1          ; 将1赋值给edx<br>    add ecx, 8          ; 将ecx加上8<br>    mov eax, [ecx + edx<em>2 - 6]  ; 将ecx+edx</em>2-6所指向的地址的值赋值给eax</p><p>; 输出字符串<br>    mov eax, 4          ; 系统调用号4代表输出字符串<br>    mov ebx, 1          ; 文件描述符1代表标准输出<br>    mov ecx, msg        ; 要输出的字符串的地址<br>    mov edx, 22         ; 要输出的字符串的长度<br>    int 0x80            ; 调用系统调用</p><p>; 退出程序<br>    mov eax, 1          ; 系统调用号1代表退出程序<br>    xor ebx, ebx        ; 返回值为0<br>    int 0x80            ; 调用系统调用</p>]]></content>
      
      
      
        <tags>
            
            <tag> 寄存器寻址 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android动态调试小记</title>
      <link href="/2025/04/01/android-dong-tai-diao-shi/"/>
      <url>/2025/04/01/android-dong-tai-diao-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="安卓动态调试——apk加上动态可调试属性"><a href="#安卓动态调试——apk加上动态可调试属性" class="headerlink" title="安卓动态调试——apk加上动态可调试属性"></a>安卓动态调试——apk加上动态可调试属性</h1><hr><p>刷了一下2024xyctf的DebugMe题目，记一下这次动态调试过程。</p><hr><p>用jeb打开后看到有调试检查，再根据题目提示为动态调试。知道需要进行动调。  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250401200202.png">  </p><p>先用雷电模拟器在程序里面运行这个程序，接着用adb测试远程连接：输入adb devices。如图显示就算端口连接好了。</p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250401200756.png">  </p><p>  adb devices -l查看连接的设备  </p><p>  adb shell ps查看线程状态  </p><p>然后才能在jeb里面点击调试器或者甲虫下图标进行动态调试，不然会显示调试的目标不存在。  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250401201241.png" alt="有可以连接的设备">    </p><p>点击attach附上。  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250401201443.png" alt="报错">   </p><p>提示程序不可调试nondebuggable。  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250401201623.png">  </p><p>提示无法attach上。   </p><h2 id="一、用Android-Killer编译的方法修改apk为可调式"><a href="#一、用Android-Killer编译的方法修改apk为可调式" class="headerlink" title="一、用Android Killer编译的方法修改apk为可调式"></a>一、用Android Killer编译的方法修改apk为可调式</h2><ol><li>用Android Killer打开apk，可以解包这个程序。</li></ol><p>​    <img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250401213521.png">  </p><ol start="2"><li><p>点开AndroidMainfest.xml，在&lt;application那一行后面加上android:debuggable=”true”这个属性（记得要ctrl+s保存）。  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250401202410.png" alt="原本的样子">  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250401202526.png" alt="更改后的样子"></p></li><li><p>把编译先设置成AndroidKiller选项，然后进行编译。会生成编译后可调试的apk（如果有报错根据提示修改）。  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250401202951.png">  </p><blockquote><p>在Android Killer工具中，<strong>“default”</strong> 和 <strong>“AndroidKiller”</strong> 是两种不同的编译配置选项，它们的核心区别在于 <strong>签名配置</strong> 和 <strong>编译参数</strong>。以下是具体分析：</p></blockquote><blockquote><h3 id="1-两者的核心区别"><a href="#1-两者的核心区别" class="headerlink" title="1. 两者的核心区别"></a><strong>1. 两者的核心区别</strong></h3><table><thead><tr><th><strong>配置项</strong></th><th><strong>default（默认配置）</strong></th><th><strong>AndroidKiller（工具自定义配置）</strong></th></tr></thead><tbody><tr><td><strong>签名文件</strong></td><td>通常使用空签名或无有效签名</td><td>预置工具自带的调试签名（如 <code>debug.keystore</code>）</td></tr><tr><td><strong>签名对齐</strong></td><td>可能未启用 <code>zipalign</code> 优化</td><td>默认启用 <code>zipalign</code> 对齐优化</td></tr><tr><td><strong>兼容性</strong></td><td>可能因签名问题导致安装失败</td><td>针对重新打包场景优化，兼容性更好</td></tr><tr><td><strong>适用场景</strong></td><td>临时测试或无需安装的场景（如静态分析）</td><td>需要重新打包并安装到设备的调试场景</td></tr></tbody></table><hr><h3 id="2-如何选择？"><a href="#2-如何选择？" class="headerlink" title="2. 如何选择？"></a><strong>2. 如何选择？</strong></h3><ul><li><strong>选择 <code>AndroidKiller</code> 配置的情况</strong>：<ul><li>需要重新打包APK并安装到设备（尤其是非Root设备）。</li><li>希望自动处理签名和对齐，避免手动操作。</li><li>遇到安装失败问题时（如 <code>INSTALL_PARSE_FAILED_NO_CERTIFICATES</code> 错误）。</li></ul></li><li><strong>选择 <code>default</code> 配置的情况</strong>：<ul><li>仅需反编译查看代码/资源，无需重新安装。</li><li>已手动配置签名文件（如自有证书）或有特殊编译需求。</li></ul></li></ul><hr><h3 id="3-验证配置差异的方法"><a href="#3-验证配置差异的方法" class="headerlink" title="3. 验证配置差异的方法"></a><strong>3. 验证配置差异的方法</strong></h3><ol><li><strong>检查签名配置</strong>：<ul><li>在Android Killer中打开 <strong><code>配置</code></strong> → <strong><code>签名配置</code></strong>，查看两种选项是否使用不同的 <code>.keystore</code> 文件。</li><li>若 <code>AndroidKiller</code> 使用 <code>debug.keystore</code> 而 <code>default</code> 为空，则前者能生成有效签名的APK。</li></ul></li><li><strong>查看编译日志</strong>：<ul><li>编译时观察日志中是否包含 <code>zipalign</code> 步骤。<code>AndroidKiller</code> 配置通常会自动对齐优化。</li></ul></li><li><strong>安装测试</strong>：<ul><li>分别用两种配置编译APK，尝试安装到模拟器或真机。若 <code>default</code> 失败，说明其签名无效。</li></ul></li></ol><hr><h3 id="4-常见问题解决"><a href="#4-常见问题解决" class="headerlink" title="4. 常见问题解决"></a><strong>4. 常见问题解决</strong></h3><ul><li><strong>安装失败（签名错误）</strong>：<ul><li>使用 <code>AndroidKiller</code> 配置（自带有效签名）。</li><li>若仍需自定义签名，手动替换配置中的 <code>.keystore</code> 文件。</li></ul></li><li><strong>APK无法运行（对齐问题）</strong>：<ul><li>确保启用 <code>zipalign</code>（在 <code>AndroidKiller</code> 配置中默认开启）。</li></ul></li></ul><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul><li><strong>优先选择 <code>AndroidKiller</code> 配置</strong>：它能自动处理签名和对齐，适合大多数重新打包场景。</li><li><strong>仅在特殊需求时使用 <code>default</code></strong>：如需自定义签名或调试未安装的APK逻辑。</li></ul><p>通过理解配置差异并针对性选择，可显著提高逆向工程和APK修改的效率。</p></blockquote></li><li><p>最后用jeb再进行动态调试，发现可以附上了，click一下flag就出来了。  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250401204037.jpg"></p></li></ol><h2 id="二、用apktool手动解包修改他的属性，再进行对齐签名的方法"><a href="#二、用apktool手动解包修改他的属性，再进行对齐签名的方法" class="headerlink" title="二、用apktool手动解包修改他的属性，再进行对齐签名的方法"></a>二、用apktool手动解包修改他的属性，再进行对齐签名的方法</h2><p>​    <em><strong>参考自视频<a href="%E3%80%90JNSEC2023-2024%E5%B9%B4%E5%BA%A6Android%E9%80%86%E5%90%91%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BE%8B%E4%BC%9A%E3%80%91https://www.bilibili.com/video/BV182421T7BS?vd_source=5f5c761091725078a8c620d82a23116b">27分21秒开始</a></strong></em>    </p><p>​    参考自文章<a href="https://blog.csdn.net/qq_25844803/article/details/84953332?ops_request_misc=%257B%2522request%255Fid%2522%253A%25221d689afc40bfd0ce9087069360d7897a%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=1d689afc40bfd0ce9087069360d7897a&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-84953332-null-null.nonecase&amp;utm_term=APK%E5%8F%8D%E7%BC%96%E8%AF%91%E9%87%8D%E6%89%93%E5%8C%85&amp;spm=1018.2226.3001.4450">APK反编译、重打包、签名之apktool实现</a></p><ol><li><p>把apk放到apk目录下面，并且在apktool目录下打开cmd输入<code>apktool d DebugeMe.apk</code>会将解包的数据输出在其目录下。  </p></li><li><p>在<em><strong>AndroidMainfest.xml</strong></em>的<strong>application</strong>里面添加<code>android:debuggable="true"</code>的<strong>属性</strong>。</p></li><li><p>再输入<code>apktool b DebugeMe</code>进行打包，打包后在DebugeMe的dist目录下看到新的apk。</p></li><li><p>生成keystone：</p><p>Keystore生成命令：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -genkey -alias abc.<span class="property">keystore</span> -keyalg <span class="variable constant_">RSA</span> -validity <span class="number">20000</span> -keystore abc.<span class="property">keystore</span></span><br></pre></td></tr></tbody></table></figure><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250401211050.png"></p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250401211117.png"></p></li><li><p>签名  </p><p>签名命令：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jarsigner -verbose -keystore abc.<span class="property">keystore</span> -signedjar <span class="title class_">TestPrint</span>_1.<span class="property">apk</span> <span class="title class_">TestPrint</span>.<span class="property">APK</span> abc.<span class="property">keystore</span></span><br></pre></td></tr></tbody></table></figure><p>输入之前填写的密码  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250401211213.png">  </p><p>此时，签名完毕，apktool文件夹下出现新的APK–&gt;TestPrint_1.apk  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250401211307.png">  </p><p>至此，apk反编译，修改文件，重打包，签名全部完成。</p></li></ol><h2 id="三、绕过apk不可调试的属性限制"><a href="#三、绕过apk不可调试的属性限制" class="headerlink" title="三、绕过apk不可调试的属性限制"></a>三、绕过apk不可调试的属性限制</h2><ul><li><strong>无需</strong>开启apk的可调试（debuggable）属性</li></ul><ol><li><p>打开<em><strong>Root权限</strong></em>和<em><strong>adb调试的远程连接模式</strong></em>  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250401211754.png">  </p></li><li><p>adb devices后，直接用jadx远程调试（点击甲虫图标）  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250401212652.png"></p></li><li><p>直接click得到flag。</p></li></ol><blockquote><h3 id="1-原APK无法调试的原因"><a href="#1-原APK无法调试的原因" class="headerlink" title="1. 原APK无法调试的原因"></a><strong>1. 原APK无法调试的原因</strong></h3><ul><li><strong>默认不可调试属性</strong>：原APK可能在构建时未设置 <code>android:debuggable="true"</code>，导致JEB/Jadx无法附加调试器（端口报错是典型表现）。</li><li><strong>调试依赖条件</strong>：正常调试需要APK的 <code>AndroidManifest.xml</code> 中明确声明可调试，否则ADB会拒绝连接。</li></ul><hr><h3 id="2-修改APK后安装失败的原因"><a href="#2-修改APK后安装失败的原因" class="headerlink" title="2. 修改APK后安装失败的原因"></a><strong>2. 修改APK后安装失败的原因</strong></h3><ul><li><strong>签名问题</strong>：修改APK后需重新签名。若未正确签名（如使用调试密钥对齐签名），雷电模拟器会拒绝安装。</li><li><strong>Manifest格式错误</strong>：手动修改XML可能导致格式错误（如标签未闭合），引发解析失败。</li><li><strong>回编工具问题</strong>：使用<code>apktool</code>等工具解包/回编时，若版本不兼容或参数错误，可能导致APK损坏。</li></ul><hr><h3 id="3-Root权限-远程ADB成功的原因"><a href="#3-Root权限-远程ADB成功的原因" class="headerlink" title="3. Root权限+远程ADB成功的原因"></a><strong>3. Root权限+远程ADB成功的原因</strong></h3><ul><li><strong>绕过调试属性限制</strong>：Root权限允许通过系统级操作（如修改 <code>ro.debuggable</code> 属性）强制开启全局调试，此时<strong>无需APK自身可调试</strong>。</li><li><strong>ADB远程连接模式</strong>：远程连接可能绕过了本地ADB的某些限制，或直接以更高权限附加到进程（如通过<code>ptrace</code>）。</li><li><strong>原APK的漏洞利用</strong>：若APK本身存在逻辑漏洞（如硬编码密钥），Root后可直接提取内存数据或修改运行时行为，无需动态调试。</li></ul><hr><h3 id="关键结论"><a href="#关键结论" class="headerlink" title="关键结论"></a><strong>关键结论</strong></h3><ul><li><strong>Root权限的作用</strong>：开启Root后，可通过系统命令（如 <code>setprop ro.debuggable 1</code>）强制允许调试所有应用，此时原APK即使未标记为可调试也能被调试。</li><li><strong>修改APK的替代方案</strong>：直接使用Root权限调试，避免了因签名或打包错误导致安装失败的问题，是一种更高效的绕过手段。</li></ul><hr><h3 id="解决方案建议"><a href="#解决方案建议" class="headerlink" title="解决方案建议"></a><strong>解决方案建议</strong></h3><ol><li><p><strong>签名验证</strong>：若需修改APK，务必用 <code>jarsigner</code> 或 <code>apksigner</code> 重新签名，并使用 <code>zipalign</code> 对齐。</p></li><li><p><strong>Root环境利用</strong>：优先在Root环境下调试，通过<code>frida</code>、<code>GDB</code>等工具直接注入或分析内存，避免修改APK的繁琐流程。</p></li><li><p><strong>系统属性修改</strong>：Root后执行以下命令强制开启全局调试：</p><p>bash</p><p>复制</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adb root          # 获取ADB Root权限</span><br><span class="line">adb shell setprop ro.debuggable 1</span><br><span class="line">adb shell stop &amp;&amp; adb shell start  # 重启ADB</span><br></pre></td></tr></tbody></table></figure><p>此后可调试任意APK，无需修改Manifest。</p></li></ol><hr><p>通过Root权限绕过APK本身的调试限制，是CTF中常见的技巧，既能避免打包错误，又能直接深入分析进程内存，是高效解题的关键。</p></blockquote><hr><p>参考文献：</p><p><a href="https://blog.csdn.net/qq_25844803/article/details/84953332?ops_request_misc=%257B%2522request%255Fid%2522%253A%25221d689afc40bfd0ce9087069360d7897a%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=1d689afc40bfd0ce9087069360d7897a&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-84953332-null-null.nonecase&amp;utm_term=APK%E5%8F%8D%E7%BC%96%E8%AF%91%E9%87%8D%E6%89%93%E5%8C%85&amp;spm=1018.2226.3001.4450">APK反编译、重打包、签名之apktool实现</a></p><p><a href="https://blog.csdn.net/zerorzeror/article/details/138043395">XYCTF 2024</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 安卓动态调试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>“gcc编译”</title>
      <link href="/2025/03/08/gcc-bian-yi/"/>
      <url>/2025/03/08/gcc-bian-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="C-编译全过程"><a href="#C-编译全过程" class="headerlink" title="C++编译全过程"></a>C++编译全过程</h1><hr><p>gcc flag.c -o flag(用gcc编译成可执行文件)  </p><h2 id="一、四个步骤："><a href="#一、四个步骤：" class="headerlink" title="一、四个步骤："></a>一、四个步骤：</h2><ol><li><p>预处理（Processing）  </p><p>  gcc -E flag.cpp -o flag.ii    <code>-E     Preprocess only; do not compile, assemble or link.</code></p></li><li><p>编译（Compilation）   </p><p>  gcc -S flag.ii -o flag.s       <code>-S      Compile only; do not assemble or link.</code></p></li><li><p>汇编（Assemble）     </p><p>  gcc -c flag.s  -o flag.o      <code>-c      Compile and assemble, but do not link.</code>  </p><p>  nasm -f elf64 -o flag.o flag.asm    # 使用 nasm 将 .asm 文件编译成 .o 文件  </p><p>  (有的asm文件nasm汇编后需要这样操作，因为他是NASM语法编写的代码，gcc无法直接处理)  </p></li><li><p>链接（linking）   </p><p>gcc -o flag flag.o           <code>-o &lt;file&gt;     Place the output into &lt;file&gt;.</code>  </p><p>ld -s -o flag flag.o     //生成可执行文件flag，-s表示在可执行文件中去掉符号表和调试信息，使得可执行文件更小。</p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250308143451.png"></p><p><img src="/image/R-C.png"></p><p><img src="/image/6ef2706a58025f5f63e7d2468db35530.png"></p></li></ol><h2 id="二、各个步骤详解："><a href="#二、各个步骤详解：" class="headerlink" title="二、各个步骤详解："></a>二、各个步骤详解：</h2><p>1. </p>]]></content>
      
      
      
        <tags>
            
            <tag> C++编译过程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编助记符</title>
      <link href="/2025/03/08/hui-bian-zhu-ji-fu/"/>
      <url>/2025/03/08/hui-bian-zhu-ji-fu/</url>
      
        <content type="html"><![CDATA[<p>offset取偏移地址，不去地址的值。  </p><p>[esi]指向对应地址的值。  </p>]]></content>
      
      
      
        <tags>
            
            <tag> 汇编语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Base64编码解析</title>
      <link href="/2025/03/06/bit/"/>
      <url>/2025/03/06/bit/</url>
      
        <content type="html"><![CDATA[<h1 id="Base64编码解析"><a href="#Base64编码解析" class="headerlink" title="Base64编码解析"></a>Base64编码解析</h1><hr><h2 id="计算机单位解析"><a href="#计算机单位解析" class="headerlink" title="计算机单位解析"></a>计算机单位解析</h2><h3 id="一、位，字节，的定义"><a href="#一、位，字节，的定义" class="headerlink" title="一、位，字节，的定义"></a>一、位，字节，的定义</h3><p>1.<a href="https://www.baidu.com/s?wd=bit&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao">bit</a>（Binary Digits）就是<a href="https://baike.baidu.com/item/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E5%AD%97/5920908?fromModule=lemma_inlink">二进制数字</a>中的位，是信息量的度量单位，为信息量的最小单位，也叫<a href="https://www.baidu.com/s?wd=%E6%AF%94%E7%89%B9%E4%BD%8D&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao">比特位</a>，<em><strong>存放一位二进制数，即0或1</strong></em>，是计算机表示数据最小的单位。  （b）</p><p>2.<a href="https://www.baidu.com/s?wd=byte&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao">byte</a>就是字节，字节(Byte)是计量单位，是计算机的基本存储单位，表示数据量多少，是计算机信息技术用于计量存储容量的一种计量单位.通常情况下一字节等于8位，一个字节由8个相邻的二进制位组成，每个位由0或1组成。字节是计算机技术中最小的可操作存储单位。  （B）  </p><h3 id="二、换算"><a href="#二、换算" class="headerlink" title="二、换算"></a>二、换算</h3><ol><li>​    1byte=8bit</li><li>​    1KB=1024B</li><li>​    1MB=1024KB</li><li>​    1G=1024MB</li><li>​    1tb=1024gb  </li><li>​    1pb=1024tb</li></ol><h3 id="三、字节与字符"><a href="#三、字节与字符" class="headerlink" title="三、字节与字符"></a>三、字节与字符</h3><ul><li><p>字符的定义：</p><ul><li><p>字符(Character)计算机中使用的字母、数字、字和符号，比如’A’、’B’、’$’、’&amp;’等。</p><p>一般在英文状态下一个字母或字符占用一个字节，一个汉字用两个字节表示。</p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250306205915.png"></p></li></ul></li></ul><ol><li>ASCII 码中，一个英文字母（不分大小写）为一个字节，一个中文汉字为两个字节。</li><li>UTF-8 编码中，一个英文字为一个字节，一个中文为三个字节。  </li><li>Unicode 编码中，一个英文为一个字节，一个中文为两个字节。  </li><li>符号：英文标点为一个字节，中文标点为两个字节。例如：英文句号 . 占1个字节的大小，中文句号  。占2个字节的大小。  </li><li>UTF-16 编码中，一个英文字母字符或一个汉字字符存储都需要 2 个字节（Unicode 扩展区的一些汉字存储需要 4 个字节）。  </li><li>UTF-32 编码中，世界上任何字符的存储都需要 4 个字节。</li></ol><h2 id="base64原理解析"><a href="#base64原理解析" class="headerlink" title="base64原理解析"></a>base64原理解析</h2><h3 id="1-base64是什么："><a href="#1-base64是什么：" class="headerlink" title="1.base64是什么："></a>1.base64是什么：</h3><blockquote><p>Base64 是一种基于 64 个可打印字符来表示<a href="https://zhida.zhihu.com/search?content_id=112952835&amp;content_type=Article&amp;match_order=1&amp;q=%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E6%8D%AE&amp;zhida_source=entity">二进制数据</a>的表示方法。由于 2^6=64，所以每 6 个比特为一个单元，对应某个可打印字符。3 个字节有 24 个比特，对应于 4 个 Base64 单元，即 3 个字节可由 4 个可打印字符来表示。<br>——维基百科</p></blockquote><p>它不是一种加解密技术，是一种简单的编解码技术。  </p><p>Base64 常用于表示、传输、存储二进制数据，也可以用于将一些含有特殊字符的文本内容编码，以便传输。</p><p>比如：</p><ol><li>在电子邮件的传输中，Base64 可以用来将 binary 的字节序列，比如附件，编码成 ASCII 字节序列；</li><li>将一些体积不大的图片 Base64 编码后，直接内嵌到网页源码里；</li><li>将要传递给 HTTP 请求的参数做简单的转换，降低肉眼可读性；<br><em>注：用于 URL 的 Base64 非标准 Base64，是一种变种。</em></li><li>网友们在论坛等公开场合习惯将邮箱地址 Base64 后再发出来，防止被爬虫抓取后发送垃圾邮件。</li></ol><h3 id="2-base64编码原理："><a href="#2-base64编码原理：" class="headerlink" title="2.base64编码原理："></a>2.base64编码原理：</h3><p>标准 Base64 里的 64 个可打印字符是 <code>A-Za-z0-9+/</code>，分别依次对应索引值 0-63。  </p><p>其中：  </p><p>​         <code>A-Z</code>、<code>a-z</code>、<code>0-9</code> 共 62 个字符</p><p>​         <code>+</code> 和 <code>/</code> 用作填充字符</p><p>​         <code>=</code> 用作填充符，使数据长度对齐到 4 字节</p><ul><li><p><strong>具体步骤</strong>：  </p><ol><li><p>将输入数据转换为二进制</p></li><li><p>将待转换的字符串每三个字节分为一组，每个字节占8bit，那么共有24个二进制位。 </p></li><li><p>将上面的24个二进制位每6个一组，共分为4组，每组对应 Base64 字符集中的一个字符，根据 Base64 字符集查找对应字符  </p></li><li><p>如果数据长度不是 3 的倍数，则先进行补0处理，再使用 <code>=</code> 填充</p><ul><li>如果最后剩下 1 个字节，那么将补 4 个 0 位，编码成 2 个 Base64 字符，然后补两个 <code>=</code></li><li>如果最后剩下 2 个字节，那么将补 2 个 0 位，编码成 3 个 Base64 字符，然后补一个 <code>=</code></li></ul><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250306212941.png">   </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250306213033.png"></p></li></ol><hr><p>参考文章：</p><p><a href="https://zhuanlan.zhihu.com/p/111700349">https://zhuanlan.zhihu.com/p/111700349</a></p><p><a href="https://www.cnblogs.com/happy-coding/p/18747324">https://www.cnblogs.com/happy-coding/p/18747324</a></p><p><a href="https://www.runoob.com/w3cnote/byte-character.html">https://www.runoob.com/w3cnote/byte-character.html</a></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机单位 </tag>
            
            <tag> 字节与字符 </tag>
            
            <tag> base64编码原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>f5报错的几种类型</title>
      <link href="/2025/03/05/f5-chu-cuo-lei-xing/"/>
      <url>/2025/03/05/f5-chu-cuo-lei-xing/</url>
      
        <content type="html"><![CDATA[<h1 id="f5生成伪代码出错的几种类型"><a href="#f5生成伪代码出错的几种类型" class="headerlink" title="f5生成伪代码出错的几种类型"></a>f5生成伪代码出错的几种类型</h1><hr><h2 id="常见F5出错信息"><a href="#常见F5出错信息" class="headerlink" title="常见F5出错信息"></a>常见F5出错信息</h2><p>1.<code>posutuve sp value has been found </code> </p><ul><li><p><strong>成因</strong>：IDA会自动分析SP寄存器的变化量，由于缺少调用约定、参数个数等信息，导致分析出错。 一般是程序代码有一些干扰代码，让IDA的反汇编分析出现错误。比如用push + n条指令 + retn来实际跳转，而IDA会以为retn是函数要结束，结果它分析后发现调用栈不平衡，因此就提示sp analysis failed。  </p></li><li><p><strong>解决方案</strong>：Option-&gt;General设置显示Stack Pointer，检查对应地址附近的调用约定以及栈指针变化。直接使用alt+k修改sp指针，将其修改为应有的值即可（可以改为指向上一行的sp或者修改为0）。（有风险）    </p></li><li><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250305210451.png"></p></li></ul><p>2.<code> cannot convert to microcode</code></p><ul><li><p><strong>成因</strong>：部分指令无法被反编译，有未设置成指令的数据字节。  </p></li><li><p><strong>解决方案</strong>：</p><ul><li>最常见起因是函数中有未设置成指令的数据字节，按c将其设置为指令即可。  </li><li>其次常见的是x86中的rep前缀，比如repxx  jmp等。可以将该指令的第一个字节(repxx前缀的对应位置)patch为0x90 (NOP)。</li><li><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250305200132.png"></li></ul></li><li><p>也可以先点击函数点u将其取消定义。  </p></li><li><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250305212604.png">  </p></li><li><p>然后选中下面所有数据内容，按C转换为代码。  </p></li><li><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250305212730.png">    </p></li><li><p>点击force  </p></li><li><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250305213156.png">  </p></li><li><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250305213246.png"></p></li><li><p>点击yes</p></li><li><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250305213235.png">  </p></li><li><p>之后再点击_Z7进行P定义为函数，再用F5反编译。这里可以得到encrypt函数。</p></li><li><p>下面如果还有红色的不要忘记也P一下，创建函数。</p></li></ul><p>3.<code>call analysis failed</code></p><ul><li><p>成因：F5在分析调用时，未能成功解析<em>参数位置/参数个苏</em></p></li><li><p>解决方案：</p><ul><li><p>对于间接调用（类似call eax等），可使用之前讲过的<em>设置调用地址</em>的方法解决。  </p></li><li><p>对于直接调用，查看调用目标的type是否正确设置。<em>可变参数</em>是引发这种错误的主要原因之一。  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250305202146.png"></p></li></ul></li></ul><p>4.<code>stack frame is too big</code></p><ul><li>成因：在分析栈帧时，IDA出现异常，导致分析出错</li><li>解决方案：<ul><li>找到明显不合常理的stack variable offset，双击进入栈帧界面，按u键删除对应的stack variable</li><li>如果是去壳导致的原因，先用OD等软件脱壳</li><li>可能由花指令导致，请手动或自动检查并去除花指令</li></ul></li><li>非常罕见</li></ul><p>5.<code>too big function</code> </p><ul><li><p>成因：当前函数大小大于允许的最大值，函数大小最大值有配置文件中的<code>MAX_FUNCSIZE </code>变量控制。  </p><p>MAX_FUNCSIZE 的定义:</p><blockquote><p>反编译函数大小最大值，使用KB单位计算。只有可读的基本块被统计在内。默认值是64，即64KB。出现这个报错，说明反编译函数的大小已经超过了64。</p></blockquote></li><li><p>解决方案：</p><p>​     1.修改配置文件：<code>【IDA 安装目录】\cfg\hexrays.cfg</code></p><p>​      源文件为：</p><ul><li><blockquote><p>MAX_FUNCSIZE            = 64        // Functions over 64K are not decompiled</p></blockquote><p>修改为：</p></li><li><blockquote><p>MAX_FUNCSIZE            = 1024        // Functions over 64K are not decompiled</p></blockquote><p>2.重新启动IDA，使配置生效。  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250305204340.png"></p></li></ul></li></ul><p>如果函数太大，逻辑太负载，及时调大<strong>MAX_FUNCSIZE</strong>也会出现新的错误，比如<strong>too complex function</strong>，这种情况就无能为力了。官方也解决不了。</p><p>如果调大以后，出现卡死问题，建议把值调小一些。</p><p>6.<code>local variable allocation failed</code>  </p><ul><li>成因： 分析函数时，有部分变量对应的区域发生重叠，多见于ARM平台出现Point、Rect等8字节、16字节、32字节结构</li><li>解决方案<ul><li>修改对应参数为多个int</li><li>修改ida安装目录下hexrays.cfg中的HO_IGNORE_OVERLAPS</li></ul></li></ul><p>7.<code> F5结果不正确</code></p><ul><li>成因：F5会自动删除其认为不可能到达的死代码</li><li>常见起因是一个函数错误的标注为noretur函数</li><li>解决方案<ul><li>进到目前反编译结果，找到最后被调用的函数(被错误分析的函数)，双击进入（迫使HexRays重新分析相应函数）</li><li>如果上述方案不成功，那么进到被错误分析的函数，按Tab切换到反汇编界面，按Alt+P进入界面取消函数的Does not return 属性</li></ul></li></ul><p>8.<code>local variable allocation failed</code></p><ul><li><p><strong>成因</strong>：</p><ul><li><p>分析函数 时，有部分变量对应的区域发生重叠，多见于ARM平台出现point rect等8字节，16字节，32字节结构时尤其多见。  </p></li><li><p>此错误消息意味着反编译器无法使用寄存器和堆栈位置分配本地变量。  </p></li><li><p>只有在配置文件中启用了HO_IGNORE_OVERLAPS之后，才会看到这个错误消息。如果输出中允许有重叠的变量，则以红色显示。</p></li></ul></li><li><p>解决方案：</p><ul><li>修改对应参数为多个int。  </li><li>更新函数堆栈帧并创建正确的堆栈变量也可以帮助解决这个问题。</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> f5报错 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>攻防世界re题目</title>
      <link href="/2025/01/27/gong-fang-shi-jie/"/>
      <url>/2025/01/27/gong-fang-shi-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="攻防世界逆向题目"><a href="#攻防世界逆向题目" class="headerlink" title="攻防世界逆向题目"></a>攻防世界逆向题目</h1><h2 id="一、1000click"><a href="#一、1000click" class="headerlink" title="一、1000click"></a>一、1000click</h2><h3 id="思路一："><a href="#思路一：" class="headerlink" title="思路一："></a>思路一：</h3><p>点开程序后发现是游戏，点击1000下可以获得flag，利用CE可以破解游戏。  </p><p>打开程序  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250127005601.png">  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250127010341.png">  </p><p>click一下，修改数值，首次扫描。  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250127010551.png">  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250127010656.png" alt="首次扫描结果">  </p><p>随便click，输入click后的值再次扫描。  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250127010901.png">  </p><p>得到唯一的基址，双击基址添加它。  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250127010955.png">  </p><p>双击下面的数值更改它成999。 </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250127011150.png">  </p><p>最后点击程序click一下，得到flag  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250127011217.png">  </p><h3 id="思路二："><a href="#思路二：" class="headerlink" title="思路二："></a>思路二：</h3><p>利用ida静态分析。</p><p>点击程序check，出现error。  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250127011530.png">  </p><p>查壳发现是32位的无壳，拖入idax32。  </p><p>在字符串处查找error。  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250127011854.png">  </p><p>跟进，ctrl x交叉引用  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250127011919.png">  </p><p>向上划一下便得到flag。  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250127012058.png">  </p>]]></content>
      
      
      
        <tags>
            
            <tag> re题目wp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>启航杯rewp</title>
      <link href="/2025/01/26/qhctfwp/"/>
      <url>/2025/01/26/qhctfwp/</url>
      
        <content type="html"><![CDATA[<h2 id="rainbow"><a href="#rainbow" class="headerlink" title=".rainbow"></a>.rainbow</h2><h2 id="一、rainbow"><a href="#一、rainbow" class="headerlink" title="一、rainbow"></a>一、rainbow</h2><h3 id="1-查壳拖入ida"><a href="#1-查壳拖入ida" class="headerlink" title="1>查壳拖入ida"></a>1&gt;查壳拖入ida</h3><p>查看伪代码</p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126230527.png">  </p><p>点击跟进hide-flag。  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126230702.png">  </p><h3 id="2-分析代码"><a href="#2-分析代码" class="headerlink" title="2>分析代码"></a>2&gt;分析代码</h3><p>点开 xor_encrypt发现是简单的异或，分析得出flag异或后得到encryped-flag。  </p><p>打开output文件。  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126231110.png">  </p><h3 id="3-写脚本"><a href="#3-写脚本" class="headerlink" title="3>写脚本"></a>3&gt;写脚本</h3><p>发现是十六进制字符串，写代码把它转换成字节再进行异或即可得到flag。  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126231702.png">  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126231742.png">   </p><h2 id="二、小明的note"><a href="#二、小明的note" class="headerlink" title="二、小明的note"></a>二、小明的note</h2><h3 id="1-查壳拖入ida-1"><a href="#1-查壳拖入ida-1" class="headerlink" title="1>查壳拖入ida"></a>1&gt;查壳拖入ida</h3><p>upx -d脱壳，进入主函数查看伪代码。  </p><p><img src="/image%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126233934.png"></p><h3 id="2-分析伪代码"><a href="#2-分析伪代码" class="headerlink" title="2>分析伪代码"></a>2&gt;分析伪代码</h3><p>进入decryped_flag，发现是dest的异或，又是异或！并且v6又是十六进制字符，要转化为字节。  </p><p>a1是dest，即长度便是dest的长度</p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126235557.png">  </p><p>往前看发现unk_2010值赋给了dest，查看unk_2010。  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250127000135.png">  </p><h3 id="3-写脚本-1"><a href="#3-写脚本-1" class="headerlink" title="3>写脚本"></a>3&gt;写脚本</h3><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250127000517.png"></p><h2 id="三、checker"><a href="#三、checker" class="headerlink" title="三、checker"></a>三、checker</h2><p>查壳32位ida分析，跟进check_flag，跟进encrypt flag，发现又是异或。</p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250127001503.png">  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250127001534.png">  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250127001556.png">  </p><p>再查看encrypted_flag  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250127002011.png">  </p><p>写脚本  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250127002240.png">  </p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛re题目wp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆向破解010 Editor</title>
      <link href="/2025/01/22/010editor/"/>
      <url>/2025/01/22/010editor/</url>
      
        <content type="html"><![CDATA[<p>前几天做misc的时候发现010Editor试用期结束了，这回无论怎么卸载再安装也没法使用了，也找不到注册码，于是我想着逆向分析一下这个程序看能不能把他给破解了，多次尝试无果，于是上网查找相关资料，最后真的成功破解了！  </p><p>接下来记录一下这次破解过程：  </p><h2 id="一-明确思路："><a href="#一-明确思路：" class="headerlink" title="一.明确思路："></a>一.明确思路：</h2><p>破解010 Editor需要注册码，如果找不出注册码，只要始终把注册标志标记为已注册，就可以成功破解。  </p><p><img src="/image/010editor.png">  </p><h2 id="二-完整流程："><a href="#二-完整流程：" class="headerlink" title="二.完整流程："></a>二.完整流程：</h2><h3 id="1-下载010-Editor"><a href="#1-下载010-Editor" class="headerlink" title="1.下载010 Editor"></a>1.下载010 Editor</h3><p>从官网<a href="https://www.sweetscape.com/010editor/" title="官网">下载010 Editor</a>  </p><h3 id="2-固定PE基址"><a href="#2-固定PE基址" class="headerlink" title="2.固定PE基址"></a>2.固定PE基址</h3><p>我们在windows逆向时，经常会遇到PE文件的基地址随机的情况，不利于反汇编的对比分析，比如利用OD反汇编时的地址和<a href="https://www.52pojie.cn/thread-1874203-1-1.html">IDA</a>反汇编时就会有不同，两者在对比分析过程中就很难对应上。  </p><p>这时我们利用反汇编查壳神器<a href="https://down.52pojie.cn/?query=studype">study PE++ x64</a>来固定基址  </p><p>把exe拖入studype，点击固定PE基址，再点击文件保存更改。  </p><p><img src="/image/studype++.png">  </p><h3 id="3-拖入x64dbg分析"><a href="#3-拖入x64dbg分析" class="headerlink" title="3.拖入x64dbg分析"></a>3.拖入x64dbg分析</h3><h4 id="1-找程序入口："><a href="#1-找程序入口：" class="headerlink" title="1>找程序入口："></a>1&gt;找程序入口：</h4><p><img src="/image/x64dbgkaishi.png" alt="拖入后的界面">  </p><p>按F9运行程序直到出现程序入口(Entrypoint)，能看到一堆jmp指令。  </p><p><img src="/image/x64dbgentrypoint.png" alt="找到了程序入口">  </p><h4 id="2-找Evaluation-Version-n："><a href="#2-找Evaluation-Version-n：" class="headerlink" title="2>找Evaluation Version\n："></a>2&gt;找Evaluation Version\n：</h4><p>接下来找突破口：</p><p><strong>！！！重点</strong>：由于一打开010editor界面会出现<em><strong>Evaluation</strong></em>！  </p><p><img src="/image/010Editorkaishi.png">  </p><p>在程序入口按<strong>Shift + D</strong>，在当前模块进行字符搜索，输入<strong>Evaluation</strong>。  </p><p><img src="/image/x64dbgEvaluation.png">  </p><p>发现四个带有换行的Evaluation Version，这四个便是我们要找的（已设置断点(f2设置断点)的四个）。  </p><p>运行一下发现听到断点处，说明这段子程序就是在程序启动时用于检查注册状态的。  </p><h4 id="3-找注册标志："><a href="#3-找注册标志：" class="headerlink" title="3>找注册标志："></a>3&gt;找注册标志：</h4><p>选一个点进去发现他们都在同一个函数的下面。  </p><p><img src="/image/dainjidasimfocasmnviapsvni.png">  </p><p>向上翻找这个函数的头部。  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126170549.png" alt="子程序头部">  </p><p>点击这个子程序函数的第一条指令查看流程图。  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126170902.png">  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126171328.png" alt="流程图">  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126171420.png" alt="总览"></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmp   edi,DB</span><br><span class="line">jne   010editor.140392FC0 // 结果不为零（或不相等）的情况下进行跳转</span><br></pre></td></tr></tbody></table></figure><blockquote><p>通过分析流程图可知，子程序流程在这里分成两个方向：EAX = 0xDB，表示各种已注册的状态，EAX &lt;&gt; 0xDB，表示各种未注册状态。由此可知，EAX = 0xDB是成功注册标志。  </p><p>找到注册标志后，改程序流向是无效的，必须找到设置注册标志的公共CALL，在CALL里边改程序流向，才能真正实现破解。</p><p>在这个程序中，判断注册标志指令是cmp edi, 0xDB，它上面的CALL是一个模块外的系统子程序调用，再往上没有CALL了，怎么办？这说明这个标志已经提前由真正的CALL算好了，下面的关键是怎么找到这个真正的CALL</p></blockquote><hr><ul><li><p><strong>cmp指令</strong>的使用和理解：  </p><p><em><strong>cmp指令</strong></em>是汇编语言中用于比较两个操作数的大小的指令。它执行的是一个隐含的减法操作，即从目的操作数中减去源操作数，但不会改变任何操作数的值。CMP指令的结果会影响处理器的标志位，这些标志位随后可以用于条件跳转指令。</p></li></ul><p>两个<strong>无符号数</strong>的比较：</p><table><thead><tr><th>CMP结果</th><th>ZF</th><th>CF</th></tr></thead><tbody><tr><td>目的操作数 ＜ 源操作数</td><td>0</td><td>1</td></tr><tr><td>目的操作数 ＞ 源操作数</td><td>0</td><td>0</td></tr><tr><td>目的操作数 = 源操作数</td><td>1</td><td>0</td></tr></tbody></table><p>两个<strong>有符号数</strong>的比较：</p><table><thead><tr><th>CMP结果</th><th>标志位</th></tr></thead><tbody><tr><td>目的操作数 ＜ 源操作数</td><td>SF ≠ OF</td></tr><tr><td>目的操作数 ＞ 源操作数</td><td>SF = OF</td></tr><tr><td>目的操作数 = 源操作数</td><td>ZF = 1</td></tr></tbody></table><ul><li><p><em><strong>jnz</strong></em>指令：</p><p><strong>JNZ</strong> 指令，全称为 <strong>Jump if Not Zero</strong>，是汇编语言中的条件转移指令。这条指令的作用是在结果不为零（或不相等）的情况下进行跳转。 </p></li><li><p><em><strong>jz</strong></em>指令</p><p>与之相对的是 <strong>JZ</strong> 指令，它在结果为零时触发跳转。在实际编程中，<strong>JNZ</strong> 通常与比较指令 <strong>CMP</strong> 或测试指令 <strong>TEST</strong> 结合使用，以根据比较或测试的结果决定程序的执行流程。</p></li></ul><hr><h4 id="4-找真正的call"><a href="#4-找真正的call" class="headerlink" title="4>找真正的call"></a>4&gt;找真正的call</h4><p>接下来脱离流程图。  </p><p>找到并选中代表<strong>注册标志</strong>的指令：cmp edi,D8  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126181532.png">  </p><p>复制他的二进制指令码，并在当前模块进行<strong>匹配特征搜索</strong>，查找所有的注册标志指令。  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126181949.png" alt="复制二进制指令码">  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126182205.png" alt="匹配特征搜索">  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126182316.png" alt="粘贴二进制码搜索">  </p><p>结果只有一个  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126182434.png">  </p><p>之后上网搜索发现使用了别的寄存器：</p><p><code>cmp eax,DB // 3D DB 00 00 00 </code>  </p><p>重新搜索匹配特征  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126183108.png" alt="3D DB 00 00 00">  </p><p>得到七个结果。  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126183330.png" alt="结果"> </p><p>挨个点击去查看  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126183632.png">  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126183731.png">   </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126183830.png">  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126183950.png">  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126184022.png">  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126184046.png">  </p><p>发现四个代码中都出现了<code>ca11 010editor.140007630</code>，所以是这个call影响了寄存器eax的值，是<em><strong>真正的call</strong></em>！    </p><p>持续跟进这个call的代码段  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126184907.png" alt="跟进">  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126184933.png" alt="再跟进">  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126184948.png" alt="最终子程序的代码段">  </p><h4 id="5-修改注册标志"><a href="#5-修改注册标志" class="headerlink" title="5>修改注册标志"></a>5&gt;修改注册标志</h4><p>由图可知这个子程序出口有很多，只要把eax的值修改为0xD8即可注册成功。  </p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">74 10          je 010editor.140392A95  </span><br><span class="line">B8 13010000    mov eax,113  </span><br></pre></td></tr></tbody></table></figure><p>修改为  </p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">74 00          je 010editor.140392A85  </span><br><span class="line">B8 DB000000    eax,DB</span><br></pre></td></tr></tbody></table></figure><p>修改前  </p><p><img src="/iamge/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126192129.png" alt="修改前">  </p><p>右键，点二进制，点编辑（Ctrl + E）,先修改je跳转，防止他乱赋值。   </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126192244.png" alt="二进制，编辑">  </p><p>修改后为  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126192543.png" alt="修改后">   </p><p>Ctrl + P或者右键，补丁，修补文件。  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126193751.png">  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126194006.png">  </p><p>发现无法修补文件</p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126194035.png">  </p><p>用IDA进行逆向，再修改Assembly（安装keypatch插件）  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126194359.png">   </p><p>发现encode值为···，点击Patch后无法修改。  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126194725.png">  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126194750.png">  </p><blockquote><p>这种情况只能通过kstool工具(支持很多架构)(git上)，手动去翻译汇编指令称机器码然后手动填写可以完成patch  </p></blockquote><blockquote><p>-&gt;&gt;kstool arm64 “需要翻译的汇编指令” [指令所在的地址]<br>-&gt;&gt;得到机器码</p></blockquote><p>由于之前我们在x64dbg修改过，得到了指令对应的机器码。  </p><h4 id="6-保存修改的补丁"><a href="#6-保存修改的补丁" class="headerlink" title="6>保存修改的补丁"></a>6&gt;保存修改的补丁</h4><p>右键机器码，点Patching，点Change byte…直接更改   </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126200251.png" alt="change byte"></p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126195802.png" alt="修改前">  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126200053.png" alt="修改后">  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126200204.png" alt="修改后">  </p><p>右键Edit，Program，Apply Patches to…来保存  </p><p><img src="/iamge/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126200449.png">   </p><h4 id="7-成功逆向"><a href="#7-成功逆向" class="headerlink" title="7>成功逆向"></a>7&gt;成功逆向</h4><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126200942.png">  </p><p><img src="/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250126201302.png" alt="成功打开"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 010 Editor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web学习记录</title>
      <link href="/2025/01/19/webknow/"/>
      <url>/2025/01/19/webknow/</url>
      
        <content type="html"><![CDATA[<h2 id="一、万能密码"><a href="#一、万能密码" class="headerlink" title="一、万能密码"></a>一、万能密码</h2><p><strong>万能密码：’ or ‘=’ #</strong><br>select * from user where username=’’or ‘=’#’ and password=’ ‘（*是通配符，#注释掉后面的语句，or前面是空的，为假，后面为真的，又因为是or语句，所以总体为真。）<br>（除了 # 以外， – 也是SQL中的注释符，但SQL的语法格式规定–和后面的注释内容必须间隔一个空格，所以这需要使用 a’ or 1 – a 而不是 a’ or 1 – 其原理和 a’ or 1 # 大同小异）     </p><h2 id="二、SQL注入"><a href="#二、SQL注入" class="headerlink" title="二、SQL注入"></a>二、SQL注入</h2><h3 id="1-SQL注入的分类："><a href="#1-SQL注入的分类：" class="headerlink" title="1.SQL注入的分类："></a>1.SQL注入的分类：</h3><p>1.根据注入位置分类：get、post、head头注入</p><ol start="2"><li><p>根据反馈结果分类：有回显（显错注入）、无回显（盲注）</p></li><li><p>根据数据类型分类：<br>                           1.数字型：0123456789<br>                           2.字符型：输入的参数为字符串。<br><em><strong>最大的区别</strong></em>：字符型不需要闭合，字符串型一般需要闭合。 </p><h3 id="2-SQL注入的流程："><a href="#2-SQL注入的流程：" class="headerlink" title="2.SQL注入的流程："></a>2.SQL注入的流程：</h3><p>？id=1asdfg  </p><h4 id="一、看是否报错："><a href="#一、看是否报错：" class="headerlink" title="一、看是否报错："></a>一、看是否报错：</h4><p>1.不报错：字符型</p><ol start="2"><li><p>报错：数字型</p><h4 id="二、看是什么闭合类型"><a href="#二、看是什么闭合类型" class="headerlink" title="二、看是什么闭合类型"></a>二、看是什么闭合类型</h4><p>id=1asdfg’（看回显，判断闭合方式）</p><p>id=1asdfg’  –+（注释掉后面内容，使运行正常，相当于– ）</p></li></ol><h4 id="三、判断列数：order-by"><a href="#三、判断列数：order-by" class="headerlink" title="三、判断列数：order by"></a>三、判断列数：order by</h4><p>?id=1asdfg’  order by 3（自己试–+</p><h4 id="四、查询回显到屏幕上的列"><a href="#四、查询回显到屏幕上的列" class="headerlink" title="四、查询回显到屏幕上的列"></a>四、查询回显到屏幕上的列</h4><p>?id=-1asdfg’ union select 1,2,3（查询出来是几列就填几)–+<br>（1改成-1，为了让页面显示出来查询的1，2，3，要让前面查询不出内容。）<br>（得到查询出来的回显位）</p><h4 id="五、获取数据名称-security"><a href="#五、获取数据名称-security" class="headerlink" title="五、获取数据名称   security"></a>五、获取数据名称   security</h4><p>?id=-1asdfg’ union select 1,database(),3–+</p><h4 id="六、获取表名-emails-referers-uagents-users"><a href="#六、获取表名-emails-referers-uagents-users" class="headerlink" title="六、获取表名     emails,referers,uagents,users"></a>六、获取表名     emails,referers,uagents,users</h4><p>?id=-1’ union select 1,(select group_concat(table_name) from information_schema.tables where table_schema=’security’),3–+</p><p>（information_schema数据库是MySQL5.0以上自带的）</p><h4 id="七、获取users表的列名-id，username，password"><a href="#七、获取users表的列名-id，username，password" class="headerlink" title="七、获取users表的列名    id，username，password"></a>七、获取users表的列名    id，username，password</h4><p>?id=-1’ union select 1,(select group_concat(column_name) from information_schema.columns where table_schema=’security’ and table_name=’users’),3–+</p><h4 id="八、获取username具体的数据"><a href="#八、获取username具体的数据" class="headerlink" title="八、获取username具体的数据"></a>八、获取username具体的数据</h4><p>?id=-1’ union select 1,(select group_concat(username) from users),3–+</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> web学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDA超全使用方法</title>
      <link href="/2025/01/14/my-first-blog/"/>
      <url>/2025/01/14/my-first-blog/</url>
      
        <content type="html"><![CDATA[<h1 id="一、IDA的下载"><a href="#一、IDA的下载" class="headerlink" title="一、IDA的下载"></a>一、IDA的下载</h1><p>ida的官网下载地址<a href="https://hex-rays.com/ida-free#download" title="ida官网">ida下载</a>，包含x64和x32.   </p><p>也可以在52破解上下载。</p><h1 id="二、IDA的介绍及如何使用"><a href="#二、IDA的介绍及如何使用" class="headerlink" title="二、IDA的介绍及如何使用"></a>二、IDA的介绍及如何使用</h1><h2 id="1-IDA简介"><a href="#1-IDA简介" class="headerlink" title="1.IDA简介"></a>1.IDA简介</h2><p>IDA，全称为<strong>交互式反汇编器专业版</strong>（Interactive Disassembler  Professional），是一款功能强大的静态反编译软件。它被广泛用于软件安全分析，尤其是在0day研究和ShellCode分析中不可或缺。IDA  Pro以其交互性、可编程性、可扩展性以及对多处理器的支持而闻名，能够在Windows、Linux、WinCE、MacOS等多个平台上运行，分析各种程序代码。  </p><p>IDA Pro支持多种CPU指令集，包括但不限于Intel  x86、x64、MIPS、PowerPC、ARM、Z80、68000和c8051。这使得IDA  Pro能够分析各种不同架构的程序，成为逆向工程领域的重要工具。IDA  Pro的递归下降反汇编能力，以及其在区分代码和数据、确定数据类型方面的高效算法，使得它能够提供接近源代码的反汇编输出。 </p><h2 id="2-在IDA中打开文件"><a href="#2-在IDA中打开文件" class="headerlink" title="2.在IDA中打开文件"></a>2.在IDA中打开文件</h2><blockquote><p><em>双击</em>ida  </p></blockquote><p><img src="/image/idajiemian.png" alt="ida"></p><blockquote><p><strong>new</strong>会打开一个空白页面，把想逆向的文件拖进去即可，或者点击<strong>go</strong>直接去打开文件。 </p></blockquote><p><img src="/image/buzhouwenjian1.png" alt="ida">  </p><h2 id="3-界面简介"><a href="#3-界面简介" class="headerlink" title="3.界面简介"></a>3.界面简介</h2><p> 打开后如下界面  </p><p><img src="/image/jiemianjieshao1.png" alt="界面简介">    </p><hr><h3 id="界面各个窗口介绍"><a href="#界面各个窗口介绍" class="headerlink" title="界面各个窗口介绍"></a>界面各个窗口介绍</h3><ul><li><p><em><strong>导航条</strong></em>的<strong>含义</strong>：</p><p>蓝色：表示常规的指令函数，绝大部分为用户编写的代码，上图中绝大部分数据属于蓝色数据。 </p><p>黑色：表示间隙部分内容，可执行文件中包含多个节段，相邻节段之间存在空隙，红色表示空隙部分。 </p><p>银白色：表示数据项部分内容，可执行文件中会包含大量数据，银白色表示数据项部分内容。 </p><p>粉色：表示外部导入符号，通常可执行文件会导入外部的库函数。 </p><p>暗黄色：表示IDA未识别的内容，需要用户根据需求自行分析。  </p></li><li><p><em><strong>IDA View</strong></em>（反汇编窗口）的<strong>含义</strong>：  </p><p>包括三种反汇编视图:文本视图、图表视图、路径视图。  </p><p>反汇编窗口属于逆向分析过程中关注频率最高的窗口，通过此窗口可以逆向分析反汇编代码。  </p></li><li><p><em><strong>Hex View</strong></em>的<strong>含义</strong>：  </p><p>二进制查看窗口总共分为三部分，三部分内容分别位于上图左、中、右，三处含义分别为：  </p><p>左边数据：表示二进制数据对应的内存相对偏移。  </p><p>中间数据：表示内存中数据的具体内容。  </p><p>右边数据：表示内存数据的字符串显示，该功能可辅助读者快速识别字符串内容。  </p><p>用户可在二进制查看窗口中编辑二进制数据，从而满足篡改数据的测试需求。  </p><p><img src="/image/view.png" alt="图标视图中红黄蓝线的应用">   </p></li><li><p><em><strong>Structures</strong></em>的<strong>含义</strong>：  </p><p>结构窗口提供用户查询已定义的结构体，同时IDA可识别出可执行文件包含的部分结构体数据，结构窗口可通过快捷键“+”、“-”展开和收缩结构体，IDA结构窗口支持用户自定义结构体。  </p></li><li><p><em><strong>Imports</strong></em>的<strong>含义</strong>：  </p><p>IDA提供导入函数窗口，用于可在导入函数窗口中查看当前可执行文件导入哪些外部函数库及函数，通过导入函数窗口可获取到函数内存相对偏移地址、函数名、导入函数所属的库文件。  </p></li><li><p><em><strong>Exports</strong></em>的<strong>含义</strong>：  </p><p>IDA的导出函数窗口提供可执行文件导出函数信息，通过导出函数窗口可获取到导出的函数名、函数对应的内存相对偏移地址。  </p></li><li><p><em><strong>Function</strong></em>的<strong>含义</strong>：</p><p>IDA提供函数窗口供玩家查找函数信息，在窗口按下“CTRL + F”快捷键便可根据需求搜索函数名，快速定位函数名方式可提供逆向分析效率。  </p></li><li><p><em><strong>Enum</strong></em>的<strong>含义</strong>：  </p><p>枚举窗口。   </p><h2 id="4-快捷键详细介绍"><a href="#4-快捷键详细介绍" class="headerlink" title="4.快捷键详细介绍"></a>4.快捷键详细介绍</h2><table><thead><tr><th align="center"><strong>快捷键</strong></th><th align="center"><strong>功能说明</strong></th></tr></thead><tbody><tr><td align="center">空格键(space)</td><td align="center">反汇编窗口切换文本与图形</td></tr><tr><td align="center">Enter</td><td align="center">跟进函数实现，查看标号对应的地址</td></tr><tr><td align="center"><strong>Esc</strong></td><td align="center">在反汇编窗口中使用为后退到上个操作的地址处</td></tr><tr><td align="center"><strong>A</strong></td><td align="center">将选择的信息转换成ASCII(转换成可读性跟强的字符串)</td></tr><tr><td align="center">B</td><td align="center">十六进制与二进制数转换</td></tr><tr><td align="center">C</td><td align="center">解释光标处的地址为一条指令（代码）</td></tr><tr><td align="center">D</td><td align="center">解释光标处的地址为数据，每按一次将会转换这个地址的数据长度</td></tr><tr><td align="center">G</td><td align="center">跳转到指定地址</td></tr><tr><td align="center">H</td><td align="center">十六进制与十进制数转换</td></tr><tr><td align="center">K</td><td align="center">将数据解释为栈变量</td></tr><tr><td align="center">M</td><td align="center">解释为枚举成员（转换为枚举类型常量）</td></tr><tr><td align="center">N</td><td align="center">对符号重新命名</td></tr><tr><td align="center">O</td><td align="center">解释地址为数据段偏移量，用于字符串标号</td></tr><tr><td align="center">P</td><td align="center">创建函数</td></tr><tr><td align="center">R</td><td align="center">将ASCII转换为字符</td></tr><tr><td align="center">T</td><td align="center">解释数据为一个结构体成员（解析结构体偏移）</td></tr><tr><td align="center">U（indefine）</td><td align="center">取消定义光标处函数、代码、数据的定义</td></tr><tr><td align="center">X</td><td align="center">转换视图到交叉参考模式</td></tr><tr><td align="center">Y</td><td align="center">设置变量类型</td></tr><tr><td align="center"><strong>/</strong></td><td align="center">伪代码中进行注释</td></tr><tr><td align="center"><strong>:</strong></td><td align="center">光标所在位置添加<strong>常规注释</strong>和可重复注释</td></tr><tr><td align="center"><strong>F2</strong></td><td align="center">设置断点（F2在十六进制窗口进行修改，然后再按F2应用）</td></tr><tr><td align="center">F4</td><td align="center">运行到光标所在处（可用于跳出循环）</td></tr><tr><td align="center">F5</td><td align="center">查看伪代码</td></tr><tr><td align="center">F7</td><td align="center">单步步进</td></tr><tr><td align="center">F9</td><td align="center">动态调试程序(其实IDA主要用作静态分析用的)</td></tr><tr><td align="center">F10</td><td align="center">打开反汇编选项菜单快捷键</td></tr><tr><td align="center">F12</td><td align="center">暂时停止</td></tr><tr><td align="center">Ctrl+F2</td><td align="center">重新开始</td></tr><tr><td align="center">Art+F2</td><td align="center">结束跟踪</td></tr><tr><td align="center">Ctrl+F7</td><td align="center">自动步入，在所有的函数调用中一条一条地执行命令，断点或异常时，自动 停止</td></tr><tr><td align="center"><strong>Shift + E</strong></td><td align="center">提取数据</td></tr><tr><td align="center"><strong>Shift</strong> + F5</td><td align="center">打开签名窗口</td></tr><tr><td align="center">Shift + F9</td><td align="center">添加结构体</td></tr><tr><td align="center">Shift + F12</td><td align="center">自动分析出参考字符串</td></tr><tr><td align="center"><strong>Ctrl</strong> + F</td><td align="center">搜索字符串</td></tr><tr><td align="center">Ctrl + M</td><td align="center">查看标签（列举出当前已经添加的标签）</td></tr><tr><td align="center">Ctrl + S</td><td align="center">查看段的信息（列举出二进制程序的段的开始地址、结束地址、权限等信息）</td></tr><tr><td align="center">Ctrl + X</td><td align="center">交叉引用,类似于OD中的栈回溯操作</td></tr><tr><td align="center">Ctrl + F9</td><td align="center">导入c头文件</td></tr><tr><td align="center">CTRL + F12</td><td align="center">函数调用图</td></tr><tr><td align="center"><strong>Alt+T</strong></td><td align="center">搜索字符串(文本搜索)(可用于搜索main函数)</td></tr><tr><td align="center">Alt+B</td><td align="center">搜索十六进制（用于搜索十六进制字节序列，通常在分析过程中可以用来搜索opcode）</td></tr><tr><td align="center">Alt+G</td><td align="center">转换局部变量为结构体</td></tr><tr><td align="center">Alt+L</td><td align="center">标记(Label)</td></tr><tr><td align="center">ALT + M</td><td align="center">添加标签(mark)</td></tr><tr><td align="center">Ctrl+Shift+W</td><td align="center">拍摄IDA快照</td></tr><tr><td align="center">view–&gt;open subviews</td><td align="center">可以恢复你无意中关闭的数据显示窗口</td></tr><tr><td align="center">windows–&gt;reset desktop</td><td align="center">可以恢复初始ida布局</td></tr><tr><td align="center">option–&gt;font</td><td align="center">option–&gt;font</td></tr><tr><td align="center">option–&gt;general-&gt;Auto comments</td><td align="center">自动添加反汇编注释</td></tr></tbody></table><h2 id="5-判断IDA分析可执行文件完毕的三种方法"><a href="#5-判断IDA分析可执行文件完毕的三种方法" class="headerlink" title="5.判断IDA分析可执行文件完毕的三种方法"></a>5.判断IDA分析可执行文件完毕的三种方法</h2><p>1.图中IDA的“Output Window”窗口输出“The initial autoanalysis has been<br> finished”日志时，则说明IDA已分析完毕。  </p><p>2.如图所示进度条处黄色向上箭头消失时，则表明IDA分析完毕。  </p><p>3.图中IDA界面左下角AU处于”idle”状态时，也表明IDA分析完毕。</p></li></ul><h1 id="三、用IDA分析程序实例"><a href="#三、用IDA分析程序实例" class="headerlink" title="三、用IDA分析程序实例"></a>三、用IDA分析程序实例</h1><h2 id="1-查壳"><a href="#1-查壳" class="headerlink" title="1.查壳"></a>1.查壳</h2><ul><li><p>使用exeinfo pe<a href="https://www.52pojie.cn/thread-1837928-1-1.html">52破解</a>查壳看他是64位还是32位的程序或者其他类型的如ELF等，以便于事后进行分析。  </p></li><li><p>或者使用peid来进行查壳<a href="https://www.softpedia.com/get/Programming/Packers-Crypters-Protectors/PEiD-updated.shtml">peid官网地址</a>。   </p><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p><img src="/image/easy64.png" alt="程序easy-64">  </p><p>拖入exeinfope后如图  </p><p><img src="/image/exeinfope.png" alt="壳"></p><p>得到程序为ELF类型的。  </p><h2 id="2-用IDA进行分析"><a href="#2-用IDA进行分析" class="headerlink" title="2.用IDA进行分析"></a>2.用IDA进行分析</h2><p>拖入IDA打开后点击main函数进行查看  </p><p>由于对于汇编代码不熟悉，点击tab键进入伪代码。  </p><p><img src="/image/easy64ida.png" alt="ida分析">  </p><p><img src="/image/easy64flag.png" alt="伪代码">  </p><p>由此我们得到了flag</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> IDA教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/01/14/hello-world/"/>
      <url>/2025/01/14/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
